
(function(global, factory) {
    "use strict";
    if (typeof module === "object" && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ?
            factory(global, true) :
            function(w) {
                if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                }
                return factory(w);
            };
    } else {
        factory(global);
    }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    };
    
    jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: "3.6.0",
        constructor: jQuery,
        // Start with an empty selector
        selector: "",
        // The default length of a jQuery object is 0
        length: 0,
        // ...
    };

    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;

    // Expose jQuery to the global object and as a AMD module
    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }

    // Pass this if window is not defined yet
    if (typeof noGlobal === "undefined") {
        window.jQuery = window.$ = jQuery;
    }

    return jQuery;
}));

function bi(a, b) {
    return f.nodeName(a, "table") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
}

function U(a) {
    var b = V.split("|"),
        c = a.createDocumentFragment();
    if (c.createElement) {
        while (b.length) {
            c.createElement(b.pop());
        }
    }
    return c;
}

function T(a, b, c) {
    b = b || 0;
    if (f.isFunction(b)) {
        return f.grep(a, function(a, d) {
            var e = !!b.call(a, d, a);
            return e === c;
        });
    }
    if (b.nodeType) {
        return f.grep(a, function(a, d) {
            return a === b === c;
        });
    }
    if (typeof b == "string") {
        var d = f.grep(a, function(a) {
            return a.nodeType === 1;
        });
        if (O.test(b)) {
            return f.filter(b, d, !c);
        }
        b = f.filter(b, d);
    }
    return f.grep(a, function(a, d) {
        return f.inArray(a, b) >= 0 === c;
    });
}

function S(a) {
    return !a || !a.parentNode || a.parentNode.nodeType === 11;
}

function K() {
    return !0;
}

function J() {
    return !1;
}

function n(a, b, c) {
    var d = b + "defer",
        e = b + "queue",
        g = b + "mark",
        h = f._data(a, d);
    h && (c === "queue" || !f._data(a, e)) && (c === "mark" || !f._data(a, g)) && setTimeout(function() {
        !f._data(a, e) && !f._data(a, g) && (f.removeData(a, d, !0), h.fire());
    }, 0);
}

function m(a) {
    for (var b in a) {
        if (b === "data" && f.isEmptyObject(a[b])) {
            continue;
        }
        if (b !== "toJSON") {
            return !1;
        }
    }
    return !0;
}

function l(a, c, d) {
    if (d === b && a.nodeType === 1) {
        var e = "data-" + c.replace(k, "-$1").toLowerCase();
        d = a.getAttribute(e);
        if (typeof d == "string") {
            try {
                d = d === "true" ? !0 : d === "false" ? !1 : d === "null" ? null : f.isNumeric(d) ? +d : j.test(d) ? f.parseJSON(d) : d;
            } catch (g) {}
            f.data(a, c, d);
        } else {
            d = b;
        }
    }
    return d;
}

function h(a) {
    var b = g[a] = {},
        c, d;
    a = a.split(/\s+/);
    for (c = 0, d = a.length; c < d; c++) {
        b[a[c]] = !0;
    }
    return b;
}
var c = a.document,
    d = a.navigator,
    e = a.location,
    f = function() {
        function J() {
            if (!e.isReady) {
                try {
                    c.documentElement.doScroll("left");
                } catch (a) {
                    setTimeout(J, 1);
                    return;
                }
                e.ready();
            }
        }
        var e = function(a, b) {
                return new e.fn.init(a, b, h);
            },
            f = a.jQuery,
            g = a.$,
            h, i = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
            j = /\S/,
            k = /^\s+/,
            l = /\s+$/,
            m = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,
            n = /^[\],:{}\s]*$/,
            o = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
            p = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            q = /(?:^|:|,)(?:\s*\[)+/g,
            r = /(webkit)[ \/]([\w.]+)/,
            s = /(opera)(?:.*version)?[ \/]([\w.]+)/,
            t = /(msie) ([\w.]+)/,
            u = /(mozilla)(?:.*? rv:([\w.]+))?/,
            v = /-([a-z]|[0-9])/ig,
            w = /^-ms-/,
            x = function(a, b) {
                return (b + "").toUpperCase();
            },
            y = d.userAgent,
            z, A, B, C = Object.prototype.toString,
            D = Object.prototype.hasOwnProperty,
            E = Array.prototype.push,
            F = Array.prototype.slice,
            G = String.prototype.trim,
            H = Array.prototype.indexOf,
            I = {};
        e.fn = e.prototype = {
            constructor: e,
            init: function(a, d, f) {
                var g, h, j, k;
                if (!a) {
                    return this;
                }
                if (a.nodeType) {
                    this.context = this[0] = a, this.length = 1;
                    return this;
                }
                if (a === "body" && !d && c.body) {
                    this.context = c, this[0] = c.body, this.selector = a, this.length = 1;
                    return this;
                }
                if (typeof a == "string") {
                    a.charAt(0) !== "<" || a.charAt(a.length - 1) !== ">" || a.length < 3 ? g = i.exec(a) : g = [null, a, null];
                    if (g && (g[1] || !d)) {
                        if (g[1]) {
                            d = d instanceof e ? d[0] : d, k = d ? d.ownerDocument || d : c, j = m.exec(a), j ? e.isPlainObject(d) ? (a = [c.createElement(j[1])], e.fn.attr.call(a, d, !0)) : a = [k.createElement(j[1])] : (j = e.buildFragment([g[1]], [k]), a = (j.cacheable ? e.clone(j.fragment) : j.fragment).childNodes);
                            return e.merge(this, a);
                        }
                        h = c.getElementById(g[2]);
                        if (h && h.parentNode) {
                            if (h.id !== g[2]) {
                                return f.find(a);
                            }
                            this.length = 1, this[0] = h;
                        }
                        this.context = c, this.selector = a;
                        return this;
                    }
                    return !d || d.jquery ? (d || f).find(a) : this.constructor(d).find(a);
                }
                if (e.isFunction(a)) {
                    return f.ready(a);
                }
                a.selector !== b && (this.selector = a.selector, this.context = a.context);
                return e.makeArray(a, this);
            },
            selector: "",
            jquery: "1.7.2",
            length: 0,
            size: function() {
                return this.length;
            },
            toArray: function() {
                return F.call(this, 0);
            },
            get: function(a) {
                return a == null ? this.toArray() : a < 0 ? this[this.length + a] : this[a];
            },
            pushStack: function(a, b, c) {
                var d = this.constructor();
                e.isArray(a) ? E.apply(d, a) : e.merge(d, a), d.prevObject = this, d.context = this.context, b === "find" ? d.selector = this.selector + (this.selector ? " " : "") + c : b && (d.selector = this.selector + "." + b + "(" + c + ")");
                return d;
            },
            each: function(a, b) {
                return e.each(this, a, b);
            },
            ready: function(a) {
                e.bindReady(), A.add(a);
                return this;
            },
            eq: function(a) {
                a = +a;
                return a === -1 ? this.slice(a) : this.slice(a, a + 1);
            },
            first: function() {
                return this.eq(0);
            },
            last: function() {
                return this.eq(-1);
            },
            slice: function() {
                return this.pushStack(F.apply(this, arguments), "slice", F.call(arguments).join(","));
            },
            map: function(a) {
                return this.pushStack(e.map(this, function(b, c) {
                    return a.call(b, c, b);
                }));
            }
        };

        e.fn.init.prototype = e.fn;

        e.extend = e.fn.extend = function() {
            var a, c, d, f, g, h, i = arguments[0] || {},
                j = 1,
                k = arguments.length,
                l = !1;
            typeof i == "boolean" && (l = i, i = arguments[1] || {}, j = 2);
            typeof i != "object" && !e.isFunction(i) && (i = {});
            k === j && (i = this, --j);
            for (; j < k; j++) {
                if ((a = arguments[j]) != null) {
                    for (c in a) {
                        d = i[c], f = a[c];
                        if (i === f) {
                            continue;
                        }
                        l && f && (e.isPlainObject(f) || (g = e.isArray(f))) ? (g ? (g = !1, h = d && e.isArray(d) ? d : []) : h = d && e.isPlainObject(d) ? d : {}, i[c] = e.extend(l, h, f)) : f !== b && (i[c] = f);
                    }
                }
            }
            return i;
        };

        e.extend({
            noConflict: function(b) {
                a.$ === e && (a.$ = g), b && a.jQuery === e && (a.jQuery = f);
                return e;
            },
            isReady: !1,
            readyWait: 1,
            holdReady: function(a) {
                a ? e.readyWait++ : e.ready(!0);
            },
            ready: function(a) {
                if (a === !0 && !--e.readyWait || a !== !0 && !e.isReady) {
                    if (!c.body) {
                        return setTimeout(e.ready, 1);
                    }
                    e.isReady = !0;
                    if (a !== !0 && --e.readyWait > 0) {
                        return;
                    }
                    A.fireWith(c, [e]), e.fn.trigger && e(c).trigger("ready").off("ready");
                }
            },
            bindReady: function() {
                if (!A) {
                    A = e.Callbacks("once memory");
                    if (c.readyState === "complete") {
                        return setTimeout(e.ready, 1);
                    }
                    if (c.addEventListener) {
                        c.addEventListener("DOMContentLoaded", B, !1), a.addEventListener("load", e.ready, !1);
                    } else if (c.attachEvent) {
                        c.attachEvent("onreadystatechange", B), a.attachEvent("onload", e.ready);
                        var b = !1;
                        try {
                            b = a.frameElement == null;
                        } catch (d) {}
                        c.documentElement.doScroll && b && J();
                    }
                }
            },
            isFunction: function(a) {
                return e.type(a) === "function";
            },
            isArray: Array.isArray || function(a) {
                return e.type(a) === "array";
            },
            isWindow: function(a) {
                return a != null && a == a.window;
            },
            isNumeric: function(a) {
                return !isNaN(parseFloat(a)) && isFinite(a);
            },
            type: function(a) {
                return a == null ? String(a) : I[C.call(a)] || "object";
            },
            isPlainObject: function(a) {
                if (!a || e.type(a) !== "object" || a.nodeType || e.isWindow(a)) {
                    return !1;
                }
                try {
                    if (a.constructor && !D.call(a, "constructor") && !D.call(a.constructor.prototype, "isPrototypeOf")) {
                        return !1;
                    }
                } catch (c) {
                    return !1;
                }
                var d;
                for (d in a) {}
                return d === b || D.call(a, d);
            },
            isEmptyObject: function(a) {
                for (var b in a) {
                    return !1;
                }
                return !0;
            },
            error: function(a) {
                throw new Error(a);
            },
            parseJSON: function(b) {
                if (typeof b != "string" || !b) {
                    return null;
                }
                b = e.trim(b);
                if (a.JSON && a.JSON.parse) {
                    return a.JSON.parse(b);
                }
                if (n.test(b.replace(o, "@").replace(p, "]").replace(q, ""))) {
                    return (new Function("return " + b))();
                }
                e.error("Invalid JSON: " + b);
            },
            parseXML: function(c) {
                var d, f;
                try {
                    a.DOMParser ? (f = new DOMParser, d = f.parseFromString(c, "text/xml")) : (d = new ActiveXObject("Microsoft.XMLDOM"), d.async = "false", d.loadXML(c));
                } catch (g) {
                    d = b;
                }
                (!d || !d.documentElement || d.getElementsByTagName("parsererror").length) && e.error("Invalid XML: " + c);
                return d;
            },
            noop: function() {},
            globalEval: function(b) {
                b && j.test(b) && (a.execScript || function(b) {
                    a.eval.call(a, b);
                })(b);
            },
            camelCase: function(a) {
                return a.replace(w, "ms-").replace(v, x);
            },
            nodeName: function(a, b) {
                return a.nodeName && a.nodeName.toUpperCase() === b.toUpperCase();
            },
            each: function(a, c, d) {
                var f, g = 0,
                    h = a.length,
                    i = h === b || e.isFunction(a);
                if (d) {
                    if (i) {
                        for (f in a) {
                            if (c.apply(a[f], d) === !1) {
                                break;
                            }
                        }
                    } else {
                        for (; g < h;) {
                            if (c.apply(a[g++], d) === !1) {
                                break;
                            }
                        }
                    }
                } else {
                    if (i) {
                        for (f in a) {
                            if (c.call(a[f], f, a[f]) === !1) {
                                break;
                            }
                        }
                    } else {
                        for (; g < h;) {
                            if (c.call(a[g], g, a[g++]) === !1) {
                                break;
                            }
                        }
                    }
                }
                return a;
            },
            trim: G ? function(a) {
                return a == null ? "" : G.call(a);
            } : function(a) {
                return a == null ? "" : (a + "").replace(k, "").replace(l, "");
            },
            makeArray: function(a, b) {
                var c = b || [];
                if (a != null) {
                    var d = e.type(a);
                    a.length == null || d === "string" || d === "function" || d === "regexp" || e.isWindow(a) ? E.call(c, a) : e.merge(c, a);
                }
                return c;
            },
            inArray: function(a, b, c) {
                var d;
                if (b) {
                    if (H) {
                        return H.call(b, a, c);
                    }
                    d = b.length, c = c ? c < 0 ? Math.max(0, d + c) : c : 0;
                    for (; c < d; c++) {
                        if (c in b && b[c] === a) {
                            return c;
                        }
                    }
                }
                return -1;
            },
            merge: function(a, c) {
                var d = a.length,
                    e = 0;
                if (typeof c.length == "number") {
                    for (var f = c.length; e < f; e++) {
                        a[d++] = c[e];
                    }
                } else {
                    while (c[e] !== b) {
                        a[d++] = c[e++];
                    }
                }
                a.length = d;
                return a;
            },
            grep: function(a, b, c) {
                var d = [],
                    e;
                c = !!c;
                for (var f = 0, g = a.length; f < g; f++) {
                    e = !!b(a[f], f), c !== e && d.push(a[f]);
                }
                return d;
            },
            map: function(a, c, d) {
                var f, g, h = [],
                    i = 0,
                    j = a.length,
                    k = a instanceof e || j !== b && typeof j == "number" && (j > 0 && a[0] && a[j - 1] || j === 0 || e.isArray(a));
                if (k) {
                    for (; i < j; i++) {
                        f = c(a[i], i, d), f != null && (h[h.length] = f);
                    }
                } else {
                    for (g in a) {
                        f = c(a[g], g, d), f != null && (h[h.length] = f);
                    }
                }
                return h.concat.apply([], h);
            },
            guid: 1,
            proxy: function(a, c) {
                if (typeof c == "string") {
                    var d = a[c];
                    c = a, a = d;
                }
                if (!e.isFunction(a)) {
                    return b;
                }
                var f = F.call(arguments, 2),
                    g = function() {
                        return a.apply(c, f.concat(F.call(arguments)));
                    };
                g.guid = a.guid = a.guid || g.guid || e.guid++;
                return g;
            },
            access: function(a, c, d, f, g, h) {
                var i = a.length;
                if (typeof c == "object") {
                    for (var j in c) {
                        e.access(a, j, c[j], f, g, d);
                    }
                    return a;
                }
                if (d !== b) {
                    f = !h && f && e.isFunction(d);
                    for (var k = 0; k < i; k++) {
                        g(a[k], c, f ? d.call(a[k], k, g(a[k], c)) : d, h);
                    }
                    return a;
                }
                return i ? g(a[0], c) : b;
            },
            now: function() {
                return (new Date).getTime();
            },
            uaMatch: function(a) {
                a = a.toLowerCase();
                var b = r.exec(a) || s.exec(a) || t.exec(a) || a.indexOf("compatible") < 0 && u.exec(a) || [];
                return {
                    browser: b[1] || "",
                    version: b[2] || "0"
                };
            },
            sub: function() {
                function a(b, c) {
                    return new a.fn.init(b, c);
                }
                e.extend(!0, a, this), a.superclass = this, a.fn = a.prototype = this(), a.fn.constructor = a, a.sub = this.sub, a.fn.init = function(d, f) {
                    f && f instanceof e && !(f instanceof a) && (f = a(f));
                    return e.fn.init.call(this, d, f, b);
                }, a.fn.init.prototype = a.fn;
                var b = a(c);
                return a;
            },
            browser: {}
        });

        e.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(a, b) {
            I["[object " + b + "]"] = b.toLowerCase();
        });

        z = e.uaMatch(y);
        if (z.browser) {
            e.browser[z.browser] = !0, e.browser.version = z.version;
        }
        if (e.browser.webkit) {
            e.browser.safari = !0;
        }
        j.test("Â ") && (k = /^[\s\xA0]+/, l = /[\s\xA0]+$/);
        h = e(c);

        if (c.addEventListener) {
            B = function() {
                c.removeEventListener("DOMContentLoaded", B, !1), e.ready();
            };
        } else if (c.attachEvent) {
            B = function() {
                if (c.readyState === "complete") {
                    c.detachEvent("onreadystatechange", B), e.ready();
                }
            };
        }

        return e;
    }(),
    g = {};
    (function (global, factory) {
        "use strict";
        if (typeof module === "object" && typeof module.exports === "object") {
            module.exports = global.document ?
                factory(global, true) :
                function (w) {
                    if (!w.document) {
                        throw new Error("jQuery requires a window with a document");
                    }
                    return factory(w);
                };
        } else {
            factory(global);
        }
    })(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
        var version = "3.6.0",
            jQuery = function (selector, context) {
                return new jQuery.fn.init(selector, context);
            };
    
        jQuery.fn = jQuery.prototype = {
            jquery: version,
            constructor: jQuery,
            length: 0,
    
            toArray: function () {
                return slice.call(this);
            },
    
            get: function (num) {
                return num != null ?
                    (num < 0 ? this[num + this.length] : this[num]) :
                    slice.call(this);
            },
    
            pushStack: function (elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                ret.prevObject = this;
                ret.context = this.context;
                return ret;
            },
    
            each: function (callback) {
                return jQuery.each(this, callback);
            },
    
            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },
    
            slice: function () {
                return this.pushStack(slice.apply(this, arguments));
            },
    
            first: function () {
                return this.eq(0);
            },
    
            last: function () {
                return this.eq(-1);
            },
    
            eq: function (i) {
                var len = this.length,
                    j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
            },
    
            end: function () {
                return this.prevObject || this.constructor();
            },
    
            push: push,
            sort: arr.sort,
            splice: arr.splice
        };
    
        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;
    
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[i] || {};
                i++;
            }
    
            if (typeof target !== "object" && !jQuery.isFunction(target)) {
                target = {};
            }
    
            if (i === length) {
                target = this;
                i--;
            }
    
            for (; i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
    
                        if (target === copy) {
                            continue;
                        }
    
                        if (deep && copy && (jQuery.isPlainObject(copy) ||
                            (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];
    
                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }
    
                            target[name] = jQuery.extend(deep, clone, copy);
    
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
    
            return target;
        };
    
        jQuery.extend({
            isReady: true,
            error: function (msg) {
                throw new Error(msg);
            },
            noop: function () {},
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },
            isArray: Array.isArray,
            isWindow: function (obj) {
                return obj != null && obj === obj.window;
            },
            isNumeric: function (obj) {
                return !isNaN(parseFloat(obj)) && isFinite(obj);
            },
            isPlainObject: function (obj) {
                var proto, Ctor;
                if (!obj || toString.call(obj) !== "[object Object]") {
                    return false;
                }
                proto = getProto(obj);
                if (!proto) {
                    return true;
                }
                Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
                return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
            },
            isEmptyObject: function (obj) {
                var name;
                for (name in obj) {
                    return false;
                }
                return true;
            },
            globalEval: function (code) {
                DOMEval(code);
            },
            each: function (obj, callback) {
                var length, i = 0;
                if (isArrayLike(obj)) {
                    length = obj.length;
                    for (; i < length; i++) {
                        if (callback.call(obj[i], i, obj[i]) === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        if (callback.call(obj[i], i, obj[i]) === false) {
                            break;
                        }
                    }
                }
                return obj;
            },
            trim: function (text) {
                return text == null ? "" : (text + "").replace(rtrim, "");
            },
            makeArray: function (arr, results) {
                var ret = results || [];
                if (arr != null) {
                    if (isArrayLike(Object(arr))) {
                        jQuery.merge(ret,
                            typeof arr === "string" ? [arr] : arr
                        );
                    } else {
                        push.call(ret, arr);
                    }
                }
                return ret;
            },
            inArray: function (elem, arr, i) {
                var len;
                if (arr) {
                    if (indexOf) {
                        return indexOf.call(arr, elem, i);
                    }
                    len = arr.length;
                    i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                    for (; i < len; i++) {
                        if (i in arr && arr[i] === elem) {
                            return i;
                        }
                    }
                }
                return -1;
            },
            merge: function (first, second) {
                var len = +second.length,
                    j = 0,
                    i = first.length;
                while (j < len) {
                    first[i++] = second[j++];
                }
                if (len !== len) {
                    while (second[j] !== undefined) {
                        first[i++] = second[j++];
                    }
                }
                first.length = i;
                return first;
            },
            grep: function (elems, callback, invert) {
                var callbackInverse,
                    matches = [],
                    i = 0,
                    length = elems.length,
                    callbackExpect = !invert;
                for (; i < length; i++) {
                    callbackInverse = !callback(elems[i], i);
                    if (callbackInverse !== callbackExpect) {
                        matches.push(elems[i]);
                    }
                }
                return matches;
            },
            map: function (elems, callback, arg) {
                var value,
                    i = 0,
                    length = elems.length,
                    isArray = isArrayLike(elems),
                    ret = [];
                if (isArray) {
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret.push(value);
                        }
                    }
                } else {
                    for (i in elems) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret.push(value);
                        }
                    }
                }
                return concat.apply([], ret);
            },
            guid: 1,
            support: support
        });
    
        if (typeof Symbol === "function") {
            jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
    
        jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
            function (i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase();
            });
    
        function isArrayLike(obj) {
            var length = !!obj && "length" in obj && obj.length,
                type = jQuery.type(obj);
    
            if (type === "function" || jQuery.isWindow(obj)) {
                return false;
            }
    
            return type === "array" || length === 0 ||
                typeof length === "number" && length > 0 && (length - 1) in obj;
        }
    
        var Sizzle =
            /*!
             * Sizzle CSS Selector Engine v2.3.6
             * https://sizzlejs.com/
             * Copyright jQuery Foundation and other contributors
             * Released under the MIT license
             * http://jquery.org/license
             * Date: 2021-02-16
             */
            (function (window) {
                var i,
                    support,
                    Expr,
                    getText,
                    isXML,
                    tokenize,
                    compile,
                    select,
                    outermostContext,
                    sortInput,
                    hasDuplicate,
    
                    // Local document vars
                    setDocument,
                    document,
                    docElem,
                    documentIsHTML,
                    rbuggyQSA,
                    rbuggyMatches,
                    matches,
                    contains,
    
                    // Instance-specific data
                    expando = "sizzle" + 1 * new Date(),
                    preferredDoc = window.document,
                    dirruns = 0,
                    done = 0,
                    classCache = createCache(),
                    tokenCache = createCache(),
                    compilerCache = createCache(),
                    nonnativeSelectorCache = createCache(),
                    sortOrder = function (a, b) {
                        if (a === b) {
                            hasDuplicate = true;
                        }
                        return 0;
                    },
    
                    // Instance methods
                    hasOwn = ({}).hasOwnProperty,
                    arr = [],
                    pop = arr.pop,
                    pushNative = arr.push,
                    push = arr.push,
                    slice = arr.slice,
                    // Use a stripped-down indexOf as it's faster than native
                    // https://jsperf.com/thor-indexof-vs-for/5
                    indexOf = function (list, elem) {
                        var i = 0,
                            len = list.length;
                        for (; i < len; i++) {
                            if (list[i] === elem) {
                                return i;
                            }
                        }
                        return -1;
                    },
    
                    booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
                    "ismap|loop|multiple|open|readonly|required|scoped",
    
                    // Regular expressions
    
                    // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
                    identifier = "(?:\\\\[\\da-fA-F]{1,6}" +
                    "|\\\\[^\\r\\n\\f])" +
                    "|[\\w-]|[^\0-\\x7f]+",
    
                    // Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
                    attributes = "\\[" + identifier + "(?:value(?:^|" + identifier + ")|(?=[\\x20\\t\\r\\n\\f]))?=",
    
                    // Pseudo-classes: https://www.w3.org/TR/selectors/#pseudo-classes
                    pseudos = ":(" + identifier + ")(?:\\((" +
                    // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                    // 1. quoted (capture the value within quotes)
                    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|" +
                    // 2. simple (capture everything not in quotes or parentheses)
                    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                    // 3. anything else (capture a single character)
                    ".*" +
                    ")\\)|)",
    
                    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                    rwhitespace = new RegExp("^" + "\\x20\\t\\r\\n\\f" +
                        "|^\\\\([\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|" +
                        "[^\\r\\n\\f\\x20\\t])" +
                        "|^" + identifier + "(?:\\\\(.*\\\\)|)" +
                        "|^$"),
    
                    // Easily-parseable/retrievable ID or TAG or CLASS selectors
                    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
    
                    // Attributeregexor
                    rcomma = new RegExp("^" + "\\x20*," + "\\x20*"),
                    rcombinators = new RegExp("^" + "\\x20*([>+~]|" + "\\x20)" + "\\x20*"),
                    rattributeQuotes = new RegExp("=" + "\\x20*([^\\]'\"]*?)" + "\\x20*\\]", "g"),
    
                    rpseudo = new RegExp(pseudos),
                    ridentifier = new RegExp("^" + identifier + "$"),
    
                    matchExpr = {
                        ID: new RegExp("^#(" + identifier + ")"),
                        CLASS: new RegExp("^\\.(" + identifier + ")"),
                        TAG: new RegExp("^(" + identifier + "|[*])"),
                        ATTR: new RegExp("^" + attributes),
                        PSEUDO: new RegExp("^" + pseudos),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
                            "(even|odd|(([+-]|)(\\d*)n|)" + "(?:([+-]|)" + "(\\d+)|)" + ")|)", "i"),
                        bool: new RegExp("^(?:" + booleans + ")$", "i"),
                        // For use in libraries implementing .is()
                        // We use this for POS matching in `select`
                        needsContext: new RegExp("^" +
                            "\\x20*[+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                            "((?:-\\d)?\\d*)" + "\\x20*([+-]\\x20*\\d+)?|)" + "\\x20*" +
                            "((?:[+-]|)" + "\\x20*\\d+|)" + "\\x20*\\)|)(?=[^-]|$)", "i")
                    },
    
                    rhtml = /HTML$/i,
                    rinputs = /^(?:input|select|textarea|button)$/i,
                    rheader = /^h\d$/i,
    
                    rnative = /^[^{]+\{\s*\[native \w/,
    
                    // Easily-parseable/retrievable ID or TAG or CLASS selectors
                    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
    
                    rsibling = /[+~]/,
    
                    // CSS escapes
                    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + "\\x20?|\\\\([^\\r\\n\\f])", "g"),
                    funescape = function (escape, nonHex) {
                        var high = "0x" + escape.slice(1) - 0x10000;
                        return nonHex ?
                            // Strip the backslash prefix from a non-hex escape sequence
                            nonHex :
                            // Replace a hexadecimal escape sequence with the encoded Unicode code point
                            // Support: IE <=11+
                            // For values outside the Basic Multilingual Plane (BMP), manually construct a
                            // surrogate pair
                            high < 0 ?
                            String.fromCharCode(high + 0x10000) :
                            // Use the full Unicode character with all six hexadecimal digits
                            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                    },
    
                    // CSS string/identifier serialization
                    // https://drafts.csswg.org/cssom/#common-serializing-idioms
                    // Escape characters reserved for CSS syntax, markup delimiters, and the nth
                    // selector value
                    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
                    fcssescape = function (ch, asCodePoint) {
                        if (asCodePoint) {
    
                            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                            if (ch === "\0") {
                                return "\uFFFD";
                            }
    
                            // Control characters and (dependent upon position) numbers get escaped as code points
                            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                        }
    
                        // Other potentially-special ASCII characters get backslash-escaped
                        return "\\" + ch;
                    },
    
                    // Used for iframes
                    // See setDocument()
                    // Removing the function wrapper causes a "Permission Denied"
                    // error in IE
                    unloadHandler = function () {
                        setDocument();
                    };
    
                // Optimize for push.apply( _, NodeList )
                try {
                    push.apply(
                        (arr = slice.call(preferredDoc.childNodes)),
                        preferredDoc.childNodes
                    );
    
                    // Support: Android<4.0
                    // Detect silently failing push.apply
                    // eslint-disable-next-line no-unused-expressions
                    arr[preferredDoc.childNodes.length].nodeType;
                } catch (e) {
                    push = {
                        apply: arr.length ?
    
                            // Leverage slice if possible
                            function (target, els) {
                                pushNative.apply(target, slice.call(els));
                            } :
    
                            // Support: IE<9
                            // Otherwise append directly
                            function (target, els) {
                                var j = target.length,
                                    i = 0;
    
                                // Can't trust NodeList.length
                                while ((target[j++] = els[i++])) {}
                                target.length = j - 1;
                            }
                    };
                }
    
                function Sizzle(selector, context, results, seed) {
                    var m, i, elem, nid, match, groups, newSelector,
                        newContext = context && context.ownerDocument,
    
                        // nodeType defaults to 9, since context defaults to document
                        nodeType = context ? context.nodeType : 9;
    
                    results = results || [];
    
                    // Return early from calls with invalid selector or context
                    if (typeof selector !== "string" || !selector ||
                        nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
    
                        return results;
                    }
    
                    // Try to shortcut find operations (as opposed to filters) in HTML documents
                    if (!seed) {
                        setDocument(context);
                        context = context || document;
    
                        if (documentIsHTML) {
    
                            // If the selector is sufficiently simple, try using a "get*By*" DOM method
                            // (excepting DocumentFragment context, where the methods don't exist)
                            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
    
                                // ID selector
                                if ((m = match[1])) {
    
                                    // Document context
                                    if (nodeType === 9) {
                                        if ((elem = context.getElementById(m))) {
    
                                            // Support: IE, Opera, Webkit
                                            // TODO: identify versions
                                            // getElementById can match elements by name instead of ID
                                            if (elem.id === m) {
                                                results.push(elem);
                                                return results;
                                            }
                                        } else {
                                            return results;
                                        }
    
                                        // Element context
                                    } else {
    
                                        // Support: IE, Opera, Webkit
                                        // TODO: identify versions
                                        // getElementById can match elements by name instead of ID
                                        if (newContext && (elem = newContext.getElementById(m)) &&
                                            contains(context, elem) &&
                                            elem.id === m) {
    
                                            results.push(elem);
                                            return results;
                                        }
                                    }
    
                                    // Type selector
                                } else if (match[2]) {
                                    push.apply(results, context.getElementsByTagName(selector));
                                    return results;
    
                                    // Class selector
                                } else if ((m = match[3]) && support.getElementsByClassName &&
                                    context.getElementsByClassName) {
    
                                    push.apply(results, context.getElementsByClassName(m));
                                    return results;
                                }
                            }
    
                            // Take advantage of querySelectorAll
                            if (support.qsa &&
                                !nonnativeSelectorCache[selector + " "] &&
                                (!rbuggyQSA || !rbuggyQSA.test(selector))) {
    
                                if (nodeType !== 1) {
                                    newContext = context;
                                    newSelector = selector;
    
                                    // qSA looks outside Element context, which is not what we want
                                    // Thanks to Andrew Dupont for this workaround technique
                                    // Support: IE <=8
                                    // Exclude object elements
                                } else if (context.nodeName.toLowerCase() !== "object") {
    
                                    // Capture the context ID, setting it first if necessary
                                    if ((nid = context.getAttribute("id"))) {
                                        nid = nid.replace(rcssescape, fcssescape);
                                    } else {
                                        context.setAttribute("id", (nid = expando));
                                    }
    
                                    // Prefix every selector in the list
                                    groups = tokenize(selector);
                                    i = groups.length;
                                    while (i--) {
                                        groups[i] = "#" + nid + " " + toSelector(groups[i]);
                                    }
                                    newSelector = groups.join(",");
    
                                    // Expand context for sibling selectors
                                    newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                                        context;
                                }
    
                                if (newSelector) {
                                    try {
                                        push.apply(results,
                                            newContext.querySelectorAll(newSelector)
                                        );
                                        return results;
                                    } catch (qsaError) {
                                    } finally {
                                        if (nid === expando) {
                                            context.removeAttribute("id");
                                        }
                                    }
                                }
                            }
                        }
                    }
    
                    // All others
                    return select(selector.replace(rtrim, "$1"), context, results, seed);
                }
    
                /**
                 * Create key-value caches of limited size
                 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
                 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                 *	deleting the oldest entry
                 */
                function createCache() {
                    var keys = [];
    
                    function cache(key, value) {
                        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                        if (keys.push(key + " ") > Expr.cacheLength) {
                            // Only keep the most recent entries
                            delete cache[keys.shift()];
                        }
                        return (cache[key + " "] = value);
                    }
                    return cache;
                }
    
                /**
                 * Mark a function for special use by Sizzle
                 * @param {Function} fn The function to mark
                 */
                function markFunction(fn) {
                    fn[expando] = true;
                    return fn;
                }
    
                /**
                 * Support testing using an element
                 * @param {Function} fn Passed the created div and expects a boolean result
                 */
                function assert(fn) {
                    var div = document.createElement("div");
    
                    try {
                        return !!fn(div);
                    } catch (e) {
                        return false;
                    } finally {
                        // Remove from its parent by default
                        if (div.parentNode) {
                            div.parentNode.removeChild(div);
                        }
                        // release memory in IE
                        div = null;
                    }
                }
    
                /**
                 * Adds the same handler for all of the specified attrs
                 * @param {String} attrs Pipe-separated list of attributes
                 * @param {Function} handler The method that will be applied
                 */
                function addHandle(attrs, handler) {
                    var arr = attrs.split("|"),
                        i = arr.length;
    
                    while (i--) {
                        Expr.attrHandle[arr[i]] = handler;
                    }
                }
    
                /**
                 * Checks document order of two siblings
                 * @param {Element} a
                 * @param {Element} b
                 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                 */
                function siblingCheck(a, b) {
                    var cur = b && a,
                        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                        a.sourceIndex - b.sourceIndex;
    
                    // Use IE sourceIndex if available on both nodes
                    if (diff) {
                        return diff;
                    }
    
                    // Check if b follows a
                    if (cur) {
                        while ((cur = cur.nextSibling)) {
                            if (cur === b) {
                                return -1;
                            }
                        }
                    }
    
                    return a ? 1 : -1;
                }
    
                /**
                 * Returns a function to use in pseudos for input types
                 * @param {String} type
                 */
                function createInputPseudo(type) {
                    return function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === "input" && elem.type === type;
                    };
                }
    
                /**
                 * Returns a function to use in pseudos for buttons
                 * @param {String} type
                 */
                function createButtonPseudo(type) {
                    return function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return (name === "input" || name === "button") && elem.type === type;
                    };
                }
    
                /**
                 * Returns a function to use in pseudos for :enabled/:disabled
                 * @param {Boolean} disabled true for :disabled; false for :enabled
                 */
                function createDisabledPseudo(disabled) {
                    // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                    return function (elem) {
    
                        // Only certain elements can match :enabled or :disabled
                        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                        if ("form" in elem) {
    
                            // Check for inherited disabledness on relevant non-disabled elements:
                            // * listed form-associated elements in a disabled fieldset
                            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                            // * option elements in a disabled optgroup
                            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                            // All such elements have a "form" property.
                            if (elem.parentNode && elem.disabled === false) {
    
                                // Option elements defer to a parent optgroup if present
                                if ("label" in elem) {
                                    if ("label" in elem.parentNode) {
                                        return elem.parentNode.disabled === disabled;
                                    } else {
                                        return elem.disabled === disabled;
                                    }
                                }
    
                                // Support: IE 6 - 11+
                                // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                                return elem.isDisabled === disabled ||
    
                                    // Where there is no isDisabled, check manually
                                    /* jshint -W018 */
                                    elem.isDisabled !== !disabled &&
                                    disabledAncestor(elem) === disabled;
                            }
    
                            return elem.disabled === disabled;
    
                            // Try to winnow out elements that can't be disabled before trusting the disabled property.
                            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                            // even exist on them, let alone have a boolean value.
                        } else if ("label" in elem) {
                            return elem.disabled === disabled;
                        }
    
                        // Remaining elements are neither :enabled nor :disabled
                        return false;
                    };
                }
    
                /**
                 * Returns a function to use in pseudos for positionals
                 * @param {Function} fn
                 */
                function createPositionalPseudo(fn) {
                    return markFunction(function (argument) {
                        argument = +argument;
                        return markFunction(function (seed, matches) {
                            var j,
                                matchIndexes = fn([], seed.length, argument),
                                i = matchIndexes.length;
    
                            // Match elements found at the specified indexes
                            while (i--) {
                                if (seed[(j = matchIndexes[i])]) {
                                    seed[j] = !(matches[j] = seed[j]);
                                }
                            }
                        });
                    });
                }
    
                /**
                 * Checks a node for validity as a Sizzle context
                 * @param {Element|Object=} context
                 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                 */
                function testContext(context) {
                    return context && typeof context.getElementsByTagName !== "undefined" && context;
                }
    
                // Expose support vars for convenience
                support = Sizzle.support = {};
    
                /**
                 * Detects XML nodes
                 * @param {Element|Object} elem An element or a document
                 * @returns {Boolean} True iff elem is a non-HTML XML node
                 */
                isXML = Sizzle.isXML = function (elem) {
                    var namespace = elem && elem.namespaceURI,
                        docElem = elem && (elem.ownerDocument || elem).documentElement;
    
                    // Support: IE <=8
                    // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
                    // https://bugs.jquery.com/ticket/4833
                    return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
                };
    
                /**
                 * Sets document-related variables once based on the current document
                 * @param {Element|Object} [doc] An element or document object to use to set the document
                 * @returns {Object} Returns the current document
                 */
                setDocument = Sizzle.setDocument = function (node) {
                    var hasCompare, subWindow,
                        doc = node ? node.ownerDocument || node : preferredDoc;
    
                    // Return early if doc is invalid or already selected
                    if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                        return document;
                    }
    
                    // Update global variables
                    document = doc;
                    docElem = document.documentElement;
                    documentIsHTML = !isXML(document);
    
                    // Support: IE 9-11+, Edge 12-18+
                    // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                    // Limit the scope of iframes in IE/Edge to the parent document unless explicitly requested
                    // eslint-disable-next-line eqeqeq
                    if (preferredDoc != document &&
                        (subWindow = document.defaultView) && subWindow.top !== subWindow) {
    
                        // Support: IE 11+, Edge
                        if (subWindow.addEventListener) {
                            subWindow.addEventListener("unload", unloadHandler, false);
    
                            // Support: IE 9 - 10 only
                        } else if (subWindow.attachEvent) {
                            subWindow.attachEvent("onunload", unloadHandler);
                        }
                    }
    
                    /* Attributes
                    ---------------------------------------------------------------------- */
    
                    // Support: IE<8
                    // Verify that getAttribute really returns attributes and not properties
                    // (excepting IE8 booleans)
                    support.attributes = assert(function (div) {
                        div.className = "i";
                        return !div.getAttribute("className");
                    });
    
                    /* getElement(s)By*
                    ---------------------------------------------------------------------- */
    
                    // Check if getElementsByTagName("*") returns only elements
                    support.getElementsByTagName = assert(function (div) {
                        div.appendChild(document.createComment(""));
                        return !div.getElementsByTagName("*").length;
                    });
    
                    // Check if getElementsByClassName can be trusted
                    support.getElementsByClassName = rnative.test(document.getElementsByClassName) && assert(function (div) {
                        div.innerHTML = "<div class='a'></div><div class='a i'></div>";
    
                        // Support: Safari<4
                        // Catch class over-caching
                        div.firstChild.className = "i";
                        // Support: Opera<10
                        // Catch gEBCN failure to find non-leading classes
                        return div.getElementsByClassName("i").length === 2;
                    });
    
                    // Support: IE<10
                    // Check if getElementById returns elements by name
                    // The broken getElementById methods don't pick up programmatically-set names,
                    // so use a roundabout getElementsByName test
                    support.getById = assert(function (div) {
                        docElem.appendChild(div).id = expando;
                        return !document.getElementsByName || !document.getElementsByName(expando).length;
                    });
    
                    // ID filter and find
                    if (support.getById) {
                        Expr.filter["ID"] = function (id) {
                            var attrId = id.replace(runescape, funescape);
                            return function (elem) {
                                return elem.getAttribute("id") === attrId;
                            };
                        };
                        Expr.find["ID"] = function (id, context) {
                            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                var elem = context.getElementById(id);
                                return elem ? [elem] : [];
                            }
                        };
                    } else {
                        Expr.filter["ID"] = function (id) {
                            var attrId = id.replace(runescape, funescape);
                            return function (elem) {
                                var node = typeof elem.getAttributeNode !== "undefined" &&
                                    elem.getAttributeNode("id");
                                return node && node.value === attrId;
                            };
                        };
    
                        // Support: IE 6 - 7 only
                        // getElementById is not reliable as a find shortcut
                        Expr.find["ID"] = function (id, context) {
                            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                var node, i, elems,
                                    elem = context.getElementById(id);
    
                                if (elem) {
    
                                    // Verify the id attribute
                                    node = elem.getAttributeNode("id");
                                    if (node && node.value === id) {
                                        return [elem];
                                    }
    
                                    // Fall back on getElementsByName
                                    elems = context.getElementsByName(id);
                                    i = 0;
                                    while ((elem = elems[i++])) {
                                        node = elem.getAttributeNode("id");
                                        if (node && node.value === id) {
                                            return [elem];
                                        }
                                    }
                                }
    
                                return [];
                            }
                        };
                    }
    
                    // Tag
                    Expr.find["TAG"] = support.getElementsByTagName ?
                        function (tag, context) {
                            if (typeof context.getElementsByTagName !== "undefined") {
                                return context.getElementsByTagName(tag);
    
                                // DocumentFragment nodes don't have gEBTN
                            } else if (support.qsa) {
                                return context.querySelectorAll(tag);
                            }
                        } :
    
                        function (tag, context) {
                            var elem,
                                tmp = [],
                                i = 0,
                                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                results = context.getElementsByTagName(tag);
    
                            // Filter out possible comments
                            if (tag === "*") {
                                while ((elem = results[i++])) {
                                    if (elem.nodeType === 1) {
                                        tmp.push(elem);
                                    }
                                }
    
                                return tmp;
                            }
                            return results;
                        };
    
                    // Class
                    Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
                        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                            return context.getElementsByClassName(className);
                        }
                    };
    
                    /* QSA/matchesSelector
                    ---------------------------------------------------------------------- */
    
                    // QSA and matchesSelector support
    
                    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                    rbuggyMatches = [];
    
                    // qSa(:focus) reports false when true (Chrome 21)
                    // We allow this because of a bug in IE8/9 that throws an error
                    // whenever `document.activeElement` is accessed on an iframe
                    // So, we allow :focus to pass through QSA all the time to avoid the IE error
                    // See https://bugs.jquery.com/ticket/13378
                    rbuggyQSA = [];
    
                    if ((support.qsa = rnative.test(document.querySelectorAll))) {
                        // Build QSA regex
                        // Regex strategy adopted from Diego Perini
                        assert(function (div) {
                            var input;
    
                            // Select is set to empty string on purpose
                            // This is to test IE's treatment of not explicitly
                            // setting a boolean content attribute,
                            // since its presence should be enough
                            // https://bugs.jquery.com/ticket/12359
                            docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" +
                                "<select id='" + expando + "-\f]' msallowcapture=''>" +
                                "<option selected=''></option></select>";
    
                            // Support: IE8, Opera 11-12.16
                            // Nothing should be selected when empty strings follow ^= or $= or *=
                            // The test attribute must be unknown in Opera but "safe" for WinRT
                            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                            if (div.querySelectorAll("[msallowcapture^='']").length) {
                                rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                            }
    
                            // Support: IE8
                            // Boolean attributes and "value" are not treated correctly
                            if (!div.querySelectorAll("[selected]").length) {
                                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                            }
    
                            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<2.0+
                            if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                                rbuggyQSA.push("~=");
                            }
    
                            // Webkit/Opera - :checked should return selected option elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            // IE8 throws error here and will not see later tests
                            if (!div.querySelectorAll(":checked").length) {
                                rbuggyQSA.push(":checked");
                            }
    
                            // Support: Safari 8+, iOS 8+
                            // https://bugs.webkit.org/show_bug.cgi?id=136851
                            // In-page `selector#id sibling-combinator selector` fails
                            if (!div.querySelectorAll("a#" + expando + "+*").length) {
                                rbuggyQSA.push(".#.+[+~]");
                            }
                        });
    
                        assert(function (div) {
                            // Support: Windows 8 Native Apps
                            // The type and name attributes are restricted during .innerHTML assignment
                            var input = document.createElement("input");
                            input.setAttribute("type", "hidden");
                            div.appendChild(input).setAttribute("name", "D");
    
                            // Support: IE8
                            // Enforce case-sensitivity of name attribute
                            if (div.querySelectorAll("[name=d]").length) {
                                rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                            }
    
                            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                            // IE8 throws error here and will not see later tests
                            if (!div.querySelectorAll(":enabled").length) {
                                rbuggyQSA.push(":enabled", ":disabled");
                            }
    
                            // Opera 10-11 does not throw on post-comma invalid pseudos
                            div.querySelectorAll("*,:x");
                            rbuggyQSA.push(",.*:");
                        });
                    }
    
                    if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                            docElem.webkitMatchesSelector ||
                            docElem.mozMatchesSelector ||
                            docElem.oMatchesSelector ||
                            docElem.msMatchesSelector)))) {
    
                        assert(function (div) {
                            // Check to see if it's possible to do matchesSelector
                            // on a disconnected node (IE 9)
                            support.disconnectedMatch = matches.call(div, "*");
    
                            // This should fail with an exception
                            // Gecko does not error, returns false instead
                            matches.call(div, "[s!='']:x");
                            rbuggyMatches.push("!=", pseudos);
                        });
                    }
    
                    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
    
                    /* Contains
                    ---------------------------------------------------------------------- */
                    hasCompare = rnative.test(docElem.compareDocumentPosition);
    
                    // Element contains another
                    // Purposefully self-exclusive
                    // As in, an element does not contain itself
                    contains = hasCompare || rnative.test(docElem.contains) ?
                        function (a, b) {
                            var adown = a.nodeType === 9 ? a.documentElement : a,
                                bup = b && b.parentNode;
                            return a === bup || !!(bup && bup.nodeType === 1 && (
                                adown.contains ?
                                adown.contains(bup) :
                                a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                            ));
                        } :
                        function (a, b) {
                            if (b) {
                                while ((b = b.parentNode)) {
                                    if (b === a) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        };
    
                    /* Sorting
                    ---------------------------------------------------------------------- */
    
                    // Document order sorting
                    sortOrder = hasCompare ?
                        function (a, b) {
    
                            // Flag for duplicate removal
                            if (a === b) {
                                hasDuplicate = true;
                                return 0;
                            }
    
                            // Sort on method existence if only one input has compareDocumentPosition
                            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                            if (compare) {
                                return compare;
                            }
    
                            // Calculate position if both inputs belong to the same document
                            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                                a.compareDocumentPosition(b) :
    
                                // Otherwise we know they are disconnected
                                1;
    
                            // Disconnected nodes
                            if (compare & 1 ||
                                (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
    
                                // Choose the first element that is related to our preferred document
                                if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                    return -1;
                                }
                                if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                    return 1;
                                }
    
                                // Maintain original order
                                return sortInput ?
                                    (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                    0;
                            }
    
                            return compare & 4 ? -1 : 1;
                        } :
                        function (a, b) {
                            // Exit early if the nodes are identical
                            if (a === b) {
                                hasDuplicate = true;
                                return 0;
                            }
    
                            var cur,
                                i = 0,
                                aup = a.parentNode,
                                bup = b.parentNode,
                                ap = [a],
                                bp = [b];
    
                            // Parentless nodes are either documents or disconnected
                            if (!aup || !bup) {
                                return a === document ? -1 :
                                    b === document ? 1 :
                                    aup ? -1 :
                                    bup ? 1 :
                                    sortInput ?
                                    (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                    0;
    
                                // If the nodes are siblings, we can do a quick check
                            } else if (aup === bup) {
                                return siblingCheck(a, b);
                            }
    
                            // Otherwise we need full lists of their ancestors for comparison
                            cur = a;
                            while ((cur = cur.parentNode)) {
                                ap.unshift(cur);
                            }
                            cur = b;
                            while ((cur = cur.parentNode)) {
                                bp.unshift(cur);
                            }
    
                            // Walk down the tree looking for a discrepancy
                            while (ap[i] === bp[i]) {
                                i++;
                            }
    
                            return i ?
                                // Do a sibling check if the nodes have a common ancestor
                                siblingCheck(ap[i], bp[i]) :
    
                                // Otherwise nodes in our document sort first
                                ap[i] === preferredDoc ? -1 :
                                bp[i] === preferredDoc ? 1 :
                                0;
                        };
    
                    return document;
                };
    
                Sizzle.matches = function (expr, elements) {
                    return Sizzle(expr, null, null, elements);
                };
    
                Sizzle.matchesSelector = function (elem, expr) {
                    // Set document vars if needed
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
    
                    // Make sure that attribute selectors are quoted
                    expr = expr.replace(rattributeQuotes, "='$1']");
    
                    if (support.matchesSelector && documentIsHTML &&
                        !compilerCache[expr + " "] &&
                        (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                        (!rbuggyQSA || !rbuggyQSA.test(expr))) {
    
                        try {
                            var ret = matches.call(elem, expr);
    
                            // IE 9's matchesSelector returns false on disconnected nodes
                            if (ret || support.disconnectedMatch ||
                                // As well, disconnected nodes are said to be in a document
                                // fragment in IE 9
                                elem.document && elem.document.nodeType !== 11) {
                                return ret;
                            }
                        } catch (e) {}
                    }
    
                    return Sizzle(expr, document, null, [elem]).length > 0;
                };
    
                Sizzle.contains = function (context, elem) {
                    // Set document vars if needed
                    if ((context.ownerDocument || context) !== document) {
                        setDocument(context);
                    }
                    return contains(context, elem);
                };
    
                Sizzle.attr = function (elem, name) {
                    // Set document vars if needed
                    if ((elem.ownerDocument || elem) !== document) {
                        setDocument(elem);
                    }
    
                    var fn = Expr.attrHandle[name.toLowerCase()],
                        // Don't get fooled by Object.prototype properties (jQuery #13807)
                        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                        fn(elem, name, !documentIsHTML) :
                        undefined;
    
                    return val !== undefined ?
                        val :
                        support.attributes || !documentIsHTML ?
                        elem.getAttribute(name) :
                        (val = elem.getAttributeNode(name)) && val.specified ?
                        val.value :
                        null;
                };
    
                Sizzle.escape = function (sel) {
                    return (sel + "").replace(rcssescape, fcssescape);
                };
    
                Sizzle.error = function (msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg);
                };
    
                /**
                 * Document sorting and removing duplicates
                 * @param {ArrayLike} results
                 */
                Sizzle.uniqueSort = function (results) {
                    var elem,
                        duplicates = [],
                        j = 0,
                        i = 0;
    
                    // Unless we *know* we can detect duplicates, assume their presence
                    hasDuplicate = !support.detectDuplicates;
                    sortInput = !support.sortStable && results.slice(0);
                    results.sort(sortOrder);
    
                    if (hasDuplicate) {
                        while ((elem = results[i++])) {
                            if (elem === results[i]) {
                                j = duplicates.push(i);
                            }
                        }
                        while (j--) {
                            results.splice(duplicates[j], 1);
                        }
                    }
    
                    // Clear input after sorting to release objects
                    // See https://github.com/jquery/sizzle/pull/225
                    sortInput = null;
    
                    return results;
                };
    
                /**
                 * Utility function for retrieving the text value of an array of DOM nodes
                 * @param {Array|Element} elem
                 */
                getText = Sizzle.getText = function (elem) {
                    var node,
                        ret = "",
                        i = 0,
                        nodeType = elem.nodeType;
    
                    if (!nodeType) {
                        // If no nodeType, this is expected to be an array
                        while ((node = elem[i++])) {
                            // Do not traverse comment nodes
                            ret += getText(node);
                        }
                    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                        // Use textContent for elements
                        // innerText usage removed for consistency of new lines (jQuery #11153)
                        if (typeof elem.textContent === "string") {
                            return elem.textContent;
                        } else {
                            // Traverse its children
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                ret += getText(elem);
                            }
                        }
                    } else if (nodeType === 3 || nodeType === 4) {
                        return elem.nodeValue;
                    }
                    // Do not include comment or processing instruction nodes
    
                    return ret;
                };
    
                Expr = Sizzle.selectors = {
    
                    // Can be adjusted by the user
                    cacheLength: 50,
    
                    createPseudo: markFunction,
    
                    match: matchExpr,
    
                    find: {},
    
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: true
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: true
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
    
                    preFilter: {
                        "ATTR": function (match) {
                            match[1] = match[1].replace(runescape, funescape);
    
                            // Move the given value to match[3] whether quoted or unquoted
                            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
    
                            if (match[2] === "~=") {
                                match[3] = " " + match[3] + " ";
                            }
    
                            return match.slice(0, 4);
                        },
    
                        "CHILD": function (match) {
                            /* matches from matchExpr["CHILD"]
                                1 type (only|nth|...)
                                2 what (child|of-type)
                                3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                                4 xn-component of xn+y argument ([+-]?\d*n|)
                                5 sign of xn-component
                                6 x of xn-component
                                7 sign of y-component
                                8 y of y-component
                            */
                            match[1] = match[1].toLowerCase();
    
                            if (match[1].slice(0, 3) === "nth") {
                                // nth-* requires argument
                                if (!match[3]) {
                                    Sizzle.error(match[0]);
                                }
    
                                // numeric x and y parameters for Expr.filter.CHILD
                                // remember that false/true cast respectively to 0/1
                                match[4] = +(match[4] ?
                                        match[5] + (match[6] || 1) :
                                        2 * (match[3] === "even" || match[3] === "odd"));
                                match[5] = +((match[7] + match[8]) || match[3] === "odd");
    
                                // other types prohibit arguments
                            } else if (match[3]) {
                                Sizzle.error(match[0]);
                            }
    
                            return match;
                        },
    
                        "PSEUDO": function (match) {
                            var excess,
                                unquoted = !match[6] && match[2];
    
                            if (matchExpr["CHILD"].test(match[0])) {
                                return null;
                            }
    
                            // Accept quoted arguments as-is
                            if (match[3]) {
                                match[2] = match[4] || match[5] || "";
    
                                // Strip excess characters from unquoted arguments
                            } else if (unquoted && rpseudo.test(unquoted) &&
                                // Get excess from tokenize (recursively)
                                (excess = tokenize(unquoted, true)) &&
                                // advance to the next closing parenthesis
                                (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
    
                                // excess is a negative index
                                match[0] = match[0].slice(0, excess);
                                match[2] = unquoted.slice(0, excess);
                            }
    
                            // Return only captures needed by the pseudo filter method (type and argument)
                            return match.slice(0, 3);
                        }
                    },
    
                    filter: {
    
                        "TAG": function (nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return nodeNameSelector === "*" ?
                                function () {
                                    return true;
                                } :
                                function (elem) {
                                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                };
                        },
    
                        "CLASS": function (className) {
                            var pattern = classCache[className + " "];
    
                            return pattern ||
                                (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                                classCache(className, function (elem) {
                                    return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                                });
                        },
    
                        "ATTR": function (name, operator, check) {
                            return function (elem) {
                                var result = Sizzle.attr(elem, name);
    
                                if (result == null) {
                                    return operator === "!=";
                                }
                                if (!operator) {
                                    return true;
                                }
    
                                result += "";
    
                                return operator === "=" ? result === check :
                                    operator === "!=" ? result !== check :
                                    operator === "^=" ? check && result.indexOf(check) === 0 :
                                    operator === "*=" ? check && result.indexOf(check) > -1 :
                                    operator === "$=" ? check && result.slice(-check.length) === check :
                                    operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                                    operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                    false;
                            };
                        },
    
                        "CHILD": function (type, what, argument, first, last) {
                            var simple = type.slice(0, 3) !== "nth",
                                forward = type.slice(-4) !== "last",
                                ofType = what === "of-type";
    
                            return first === 1 && last === 0 ?
    
                                // Shortcut for :nth-*(n)
                                function (elem) {
                                    return !!elem.parentNode;
                                } :
    
                                function (elem, context, xml) {
                                    var cache, outerCache, node, diff, nodeIndex, start,
                                        dir = simple !== forward ? "nextSibling" : "previousSibling",
                                        parent = elem.parentNode,
                                        name = ofType && elem.nodeName.toLowerCase(),
                                        useCache = !xml && !ofType,
                                        diffVal = false;
    
                                    if (parent) {
    
                                        // :(first|last|only)-(child|of-type)
                                        if (simple) {
                                            while (dir) {
                                                node = elem;
                                                while ((node = node[dir])) {
                                                    if (ofType ?
                                                        node.nodeName.toLowerCase() === name :
                                                        node.nodeType === 1) {
    
                                                        return false;
                                                    }
                                                }
                                                // Reverse direction for :only-* (if we haven't yet done so)
                                                start = dir = type === "only" && !start && "nextSibling";
                                            }
                                            return true;
                                        }
    
                                        start = [forward ? parent.firstChild : parent.lastChild];
    
                                        // non-xml :nth-child(...) stores cache data on `parent`
                                        if (forward && useCache) {
                                            // Seek `elem` from a previously-cached index
                                            outerCache = parent[expando] || (parent[expando] = {});
                                            cache = outerCache[type] || [];
                                            nodeIndex = cache[0] === dirruns && cache[1];
                                            diff = cache[0] === dirruns && cache[2];
                                            node = nodeIndex && parent.childNodes[nodeIndex];
    
                                            while ((node = ++nodeIndex && node && node[dir] ||
    
                                                    // Fallback to seeking `elem` from the start
                                                    (diffVal = nodeIndex = 0) || start.pop())) {
    
                                                // When found, cache indexes on `parent` and break
                                                if (node.nodeType === 1 && ++diff && node === elem) {
                                                    outerCache[type] = [dirruns, nodeIndex, diff];
                                                    break;
                                                }
                                            }
    
                                            // Use previously-cached element index if available
                                        } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                                            diff = cache[1];
    
                                            // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                        } else {
                                            // Use the same loop as above to seek `elem` from the start
                                            while ((node = ++nodeIndex && node && node[dir] ||
                                                    (diffVal = nodeIndex = 0) || start.pop())) {
    
                                                if ((ofType ?
                                                        node.nodeName.toLowerCase() === name :
                                                        node.nodeType === 1) && ++diff) {
    
                                                    // Cache the index of each encountered element
                                                    if (useCache) {
                                                        (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                                                    }
    
                                                    if (node === elem) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
    
                                        // Incorporate the offset, then check against cycle size
                                        diff -= last;
                                        return diff === first || (diff % first === 0 && diff / first >= 0);
                                    }
                                };
                        },
    
                        "PSEUDO": function (pseudo, argument) {
                            // pseudo-class names are case-insensitive
                            // http://www.w3.org/TR/selectors/#pseudo-classes
                            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                            // Remember that setFilters inherits from pseudos
                            var args,
                                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                Sizzle.error("unsupported pseudo: " + pseudo);
    
                            // The user may use createPseudo to indicate that
                            // arguments are needed to create the filter function
                            // just as Sizzle does
                            if (fn[expando]) {
                                return fn(argument);
                            }
    
                            // But maintain support for old signatures
                            if (fn.length > 1) {
                                args = [pseudo, pseudo, "", argument];
                                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                    markFunction(function (seed, matches) {
                                        var idx,
                                            matched = fn(seed, argument),
                                            i = matched.length;
                                        while (i--) {
                                            idx = indexOf(seed, matched[i]);
                                            seed[idx] = !(matches[idx] = matched[i]);
                                        }
                                    }) :
                                    function (elem) {
                                        return fn(elem, 0, args);
                                    };
                            }
    
                            return fn;
                        }
                    },
    
                    pseudos: {
                        // Potentially complex pseudos
                        "not": markFunction(function (selector) {
                            // Trim the selector passed to compile
                            // to avoid treating leading and trailing
                            // spaces as combinators
                            var input = [],
                                results = [],
                                matcher = compile(selector.replace(rtrim, "$1"));
    
                            return matcher[expando] ?
                                markFunction(function (seed, matches, context, xml) {
                                    var elem,
                                        unmatched = matcher(seed, null, xml, []),
                                        i = seed.length;
    
                                    // Match elements unmatched by `matcher`
                                    while (i--) {
                                        if ((elem = unmatched[i])) {
                                            seed[i] = !(matches[i] = elem);
                                        }
                                    }
                                }) :
                                function (elem, context, xml) {
                                    input[0] = elem;
                                    matcher(input, null, xml, results);
                                    // Don't keep the element (issue #299)
                                    input[0] = null;
                                    return !results.pop();
                                };
                        }),
    
                        "has": markFunction(function (selector) {
                            return function (elem) {
                                return Sizzle(selector, elem).length > 0;
                            };
                        }),
    
                        "contains": markFunction(function (text) {
                            text = text.replace(runescape, funescape);
                            return function (elem) {
                                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                            };
                        }),
    
                        // "Whether an element is represented by a :lang() selector
                        // is based solely on the element's language value
                        // being equal to the identifier C,
                        // or beginning with the identifier C immediately followed by "-".
                        // The matching of C against the element's language value is performed case-insensitively.
                        // The identifier C does not have to be a valid language name."
                        // http://www.w3.org/TR/selectors/#lang-pseudo
                        "lang": markFunction(function (lang) {
                            // lang value must be a valid identifier
                            if (!ridentifier.test(lang || "")) {
                                Sizzle.error("unsupported lang: " + lang);
                            }
                            lang = lang.replace(runescape, funescape).toLowerCase();
                            return function (elem) {
                                var elemLang;
                                do {
                                    if ((elemLang = documentIsHTML ?
                                            elem.lang :
                                            elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
    
                                        elemLang = elemLang.toLowerCase();
                                        return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                    }
                                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                return false;
                            };
                        }),
    
                        // Miscellaneous
                        "target": function (elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id;
                        },
    
                        "root": function (elem) {
                            return elem === docElem;
                        },
    
                        "focus": function (elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                        },
    
                        // Boolean properties
                        "enabled": createDisabledPseudo(false),
                        "disabled": createDisabledPseudo(true),
    
                        "checked": function (elem) {
                            // In CSS3, :checked should return both checked and selected elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            var nodeName = elem.nodeName.toLowerCase();
                            return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                        },
    
                        "selected": function (elem) {
                            // Accessing this property makes selected-by-default
                            // options in Safari work properly
                            if (elem.parentNode) {
                                elem.parentNode.selectedIndex;
                            }
    
                            return elem.selected === true;
                        },
    
                        // Contents
                        "empty": function (elem) {
                            // http://www.w3.org/TR/selectors/#empty-pseudo
                            // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
                            //   not comment, processing instructions, or others
                            // Thanks to Diego Perini for the nodeName shortcut
                            //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                if (elem.nodeType < 6) {
                                    return false;
                                }
                            }
                            return true;
                        },
    
                        "parent": function (elem) {
                            return !Expr.pseudos["empty"](elem);
                        },
    
                        // Element/input types
                        "header": function (elem) {
                            return rheader.test(elem.nodeName);
                        },
    
                        "input": function (elem) {
                            return rinputs.test(elem.nodeName);
                        },
    
                        "button": function (elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === "button" || name === "button";
                        },
    
                        "text": function (elem) {
                            var attr;
                            return elem.nodeName.toLowerCase() === "input" &&
                                elem.type === "text" &&
    
                                // Support: IE<8
                                // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                        },
    
                        // Position-in-collection
                        "first": createPositionalPseudo(function () {
                            return [0];
                        }),
    
                        "last": createPositionalPseudo(function (matchIndexes, length) {
                            return [length - 1];
                        }),
    
                        "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
                            return [argument < 0 ? argument + length : argument];
                        }),
    
                        "even": createPositionalPseudo(function (matchIndexes, length) {
                            var i = 0;
                            for (; i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
    
                        "odd": createPositionalPseudo(function (matchIndexes, length) {
                            var i = 1;
                            for (; i < length; i += 2) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
    
                        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument;
                            for (; --i >= 0;) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        }),
    
                        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
                            var i = argument < 0 ? argument + length : argument;
                            for (; ++i < length;) {
                                matchIndexes.push(i);
                            }
                            return matchIndexes;
                        })
                    }
                };
    
                Expr.pseudos["nth"] = Expr.pseudos["eq"];
    
                // Add button/input type pseudos
                for (i in {
                        radio: true,
                        checkbox: true,
                        file: true,
                        password: true,
                        image: true
                    }) {
                    Expr.pseudos[i] = createInputPseudo(i);
                }
                for (i in {
                        submit: true,
                        reset: true
                    }) {
                    Expr.pseudos[i] = createButtonPseudo(i);
                }
    
                // Easy API for creating new setFilters
                function setFilters() {}
                setFilters.prototype = Expr.filters = Expr.pseudos;
                Expr.setFilters = new setFilters();
    
                tokenCache = Sizzle.tokenize = function (selector, parseOnly) {
                    var matched, match, tokens, type,
                        soFar, groups, preFilters,
                        cached = tokenCache[selector + " "];
    
                    if (cached) {
                        return parseOnly ? 0 : cached.slice(0);
                    }
    
                    soFar = selector;
                    groups = [];
                    preFilters = Expr.preFilter;
    
                    while (soFar) {
    
                        // Comma and first run
                        if (!matched || (match = rcomma.exec(soFar))) {
                            if (match) {
                                // Don't consume trailing commas as valid
                                soFar = soFar.slice(match[0].length) || soFar;
                            }
                            groups.push((tokens = []));
                        }
    
                        matched = false;
    
                        // Combinators
                        if ((match = rcombinators.exec(soFar))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                // Cast descendant combinators to space
                                type: match[0].replace(rtrim, " ")
                            });
                            soFar = soFar.slice(matched.length);
                        }
    
                        // Filters
                        for (type in Expr.filter) {
                            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                                    (match = preFilters[type](match)))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    type: type,
                                    matches: match
                                });
                                soFar = soFar.slice(matched.length);
                            }
                        }
    
                        if (!matched) {
                            break;
                        }
                    }
    
                    // Return the length of the invalid excess
                    // if we're just parsing
                    // Otherwise, throw an error or return tokens
                    return parseOnly ?
                        soFar.length :
                        soFar ?
                        Sizzle.error(selector) :
                        // Cache the tokens
                        tokenCache(selector, groups).slice(0);
                };
    
                function toSelector(tokens) {
                    var i = 0,
                        len = tokens.length,
                        selector = "";
                    for (; i < len; i++) {
                        selector += tokens[i].value;
                    }
                    return selector;
                }
    
                function addCombinator(matcher, combinator, base) {
                    var dir = combinator.dir,
                        skip = combinator.next,
                        key = skip || dir,
                        checkNonElements = base && key === "parentNode",
                        doneName = done++;
    
                    return combinator.first ?
                        // Check against closest ancestor/preceding element
                        function (elem, context, xml) {
                            while ((elem = elem[dir])) {
                                if (elem.nodeType === 1 || checkNonElements) {
                                    return matcher(elem, context, xml);
                                }
                            }
                            return false;
                        } :
    
                        // Check against all ancestor/preceding elements
                        function (elem, context, xml) {
                            var oldCache, uniqueCache, outerCache,
                                newCache = [dirruns, doneName];
    
                            // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                            if (xml) {
                                while ((elem = elem[dir])) {
                                    if (elem.nodeType === 1 || checkNonElements) {
                                        if (matcher(elem, context, xml)) {
                                            return true;
                                        }
                                    }
                                }
                            } else {
                                while ((elem = elem[dir])) {
                                    if (elem.nodeType === 1 || checkNonElements) {
                                        outerCache = elem[expando] || (elem[expando] = {});
    
                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
    
                                        if (skip && skip === elem.nodeName.toLowerCase()) {
                                            elem = elem[dir] || elem;
                                        } else if ((oldCache = uniqueCache[key]) &&
                                            oldCache[0] === dirruns && oldCache[1] === doneName) {
    
                                            // Assign to newCache so results back-propagate to previous elements
                                            return (newCache[2] = oldCache[2]);
                                        } else {
                                            // Reuse newcache so results back-propagate to previous elements
                                            uniqueCache[key] = newCache;
    
                                            // A match means we're done; a fail means we have to keep checking
                                            if ((newCache[2] = matcher(elem, context, xml))) {
                                                return true;
                                            }
                                        }
                                    }
                                }
                            }
                            return false;
                        };
                }
    
                function elementMatcher(matchers) {
                    return matchers.length > 1 ?
                        function (elem, context, xml) {
                            var i = matchers.length;
                            while (i--) {
                                if (!matchers[i](elem, context, xml)) {
                                    return false;
                                }
                            }
                            return true;
                        } :
                        matchers[0];
                }
    
                function multipleContexts(selector, contexts, results) {
                    var i = 0,
                        len = contexts.length;
                    for (; i < len; i++) {
                        Sizzle(selector, contexts[i], results);
                    }
                    return results;
                }
    
                function condense(unmatched, map, filter, context, xml) {
                    var elem,
                        newUnmatched = [],
                        i = 0,
                        len = unmatched.length,
                        mapped = map != null;
    
                    for (; i < len; i++) {
                        if ((elem = unmatched[i])) {
                            if (!filter || filter(elem, context, xml)) {
                                newUnmatched.push(elem);
                                if (mapped) {
                                    map.push(i);
                                }
                            }
                        }
                    }
    
                    return newUnmatched;
                }
    
                function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                    if (postFilter && !postFilter[expando]) {
                        postFilter = setMatcher(postFilter);
                    }
                    if (postFinder && !postFinder[expando]) {
                        postFinder = setMatcher(postFinder, postSelector);
                    }
                    return markFunction(function (seed, results, context, xml) {
                        var temp, i, elem,
                            preMap = [],
                            postMap = [],
                            preexisting = results.length,
    
                            // Get initial elements from seed or context
                            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
    
                            // Prefilter to get matcher input, preserving a map for seed-results synchronization
                            matcherIn = preFilter && (seed || !selector) ?
                            condense(elems, preMap, preFilter, context, xml) :
                            elems,
    
                            matcherOut = matcher ?
                            // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                            postFinder || (seed ? preFilter : preexisting || postFilter) ?
    
                            // ...intermediate processing is necessary
                            [] :
    
                            // ...otherwise use results directly
                            results :
                            matcherIn;
    
                        // Find primary matches
                        if (matcher) {
                            matcher(matcherIn, matcherOut, context, xml);
                        }
    
                        // Apply postFilter
                        if (postFilter) {
                            temp = condense(matcherOut, postMap);
                            postFilter(temp, [], context, xml);
    
                            // Un-match failing elements by moving them back to matcherIn
                            i = temp.length;
                            while (i--) {
                                if ((elem = temp[i])) {
                                    matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                }
                            }
                        }
    
                        if (seed) {
                            if (postFinder || preFilter) {
                                if (postFinder) {
                                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                    temp = [];
                                    i = matcherOut.length;
                                    while (i--) {
                                        if ((elem = matcherOut[i])) {
                                            // Restore matcherIn since elem is not yet a final match
                                            temp.push((matcherIn[i] = elem));
                                        }
                                    }
                                    postFinder(null, (matcherOut = []), temp, xml);
                                }
    
                                // Move matched elements from seed to results to keep them synchronized
                                i = matcherOut.length;
                                while (i--) {
                                    if ((elem = matcherOut[i]) &&
                                        (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
    
                                        seed[temp] = !(results[temp] = elem);
                                    }
                                }
                            }
    
                            // Add elements to results, through postFinder if defined
                        } else {
                            matcherOut = condense(
                                matcherOut === results ?
                                matcherOut.splice(preexisting, matcherOut.length) :
                                matcherOut
                            );
                            if (postFinder) {
                                postFinder(null, results, matcherOut, xml);
                            } else {
                                push.apply(results, matcherOut);
                            }
                        }
                    });
                }
    
                function matcherFromTokens(tokens) {
                    var checkContext, matcher, j,
                        len = tokens.length,
                        leadingRelative = Expr.relative[tokens[0].type],
                        implicitRelative = leadingRelative || Expr.relative[" "],
                        i = leadingRelative ? 1 : 0,
    
                        // The foundational matcher ensures that elements are reachable from top-level context(s)
                        matchContext = addCombinator(function (elem) {
                            return elem === checkContext;
                        }, implicitRelative, true),
                        matchAnyContext = addCombinator(function (elem) {
                            return indexOf(checkContext, elem) > -1;
                        }, implicitRelative, true),
                        matchers = [function (elem, context, xml) {
                            var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
                                (checkContext = context).nodeType ?
                                matchContext(elem, context, xml) :
                                matchAnyContext(elem, context, xml));
                            // Avoid hanging onto element (issue #299)
                            checkContext = null;
                            return ret;
                        }];
    
                    for (; i < len; i++) {
                        if ((matcher = Expr.relative[tokens[i].type])) {
                            matchers = [addCombinator(elementMatcher(matchers), matcher)];
                        } else {
                            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
    
                            // Return special upon seeing a positional matcher
                            if (matcher[expando]) {
                                // Find the next relative operator (if any) for proper handling
                                j = ++i;
                                for (; j < len; j++) {
                                    if (Expr.relative[tokens[j].type]) {
                                        break;
                                    }
                                }
                                return setMatcher(
                                    i > 1 && elementMatcher(matchers),
                                    i > 1 && toSelector(
                                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                        tokens.slice(0, i - 1).concat({
                                            value: tokens[i - 2].type === " " ? "*" : ""
                                        })
                                    ).replace(rtrim, "$1"),
                                    matcher,
                                    i < j && matcherFromTokens(tokens.slice(i, j)),
                                    j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                    j < len && toSelector(tokens)
                                );
                            }
                            matchers.push(matcher);
                        }
                    }
    
                    return elementMatcher(matchers);
                }
    
                function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                    var bySet = setMatchers.length > 0,
                        byElement = elementMatchers.length > 0,
                        superMatcher = function (seed, context, xml, results, outermost) {
                            var elem, j, matcher,
                                matchedCount = 0,
                                i = "0",
                                unmatched = seed && [],
                                setMatched = [],
                                contextBackup = outermostContext,
                                // We must always have either seed elements or outermost context
                                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                                // Use integer dirruns iff this is the outermost matcher
                                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                len = elems.length;
    
                            if (outermost) {
                                outermostContext = context === document || context || outermost;
                            }
    
                            // Add elements passing elementMatchers directly to results
                            // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
                            // Support: IE<9, Safari
                            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                            for (; i !== len && (elem = elems[i]) != null; i++) {
                                if (byElement && elem) {
                                    j = 0;
                                    if (!context && elem.ownerDocument !== document) {
                                        setDocument(elem);
                                        xml = !documentIsHTML;
                                    }
                                    while ((matcher = elementMatchers[j++])) {
                                        if (matcher(elem, context || document, xml)) {
                                            results.push(elem);
                                            break;
                                        }
                                    }
                                    if (outermost) {
                                        dirruns = dirrunsUnique;
                                    }
                                }
    
                                // Track unmatched elements for set filters
                                if (bySet) {
                                    // They will have gone through all possible matchers
                                    if ((elem = !matcher && elem)) {
                                        matchedCount--;
                                    }
    
                                    // Lengthen the array for every element, matched or not
                                    if (seed) {
                                        unmatched.push(elem);
                                    }
                                }
                            }
    
                            // Apply set filters to unmatched elements
                            matchedCount += i;
                            if (bySet && i !== matchedCount) {
                                j = 0;
                                while ((matcher = setMatchers[j++])) {
                                    matcher(unmatched, setMatched, context, xml);
                                }
    
                                if (seed) {
                                    // Reintegrate element matches to eliminate the need for sorting
                                    if (matchedCount > 0) {
                                        while (i--) {
                                            if (!(unmatched[i] || setMatched[i])) {
                                                setMatched[i] = pop.call(results);
                                            }
                                        }
                                    }
    
                                    // Discard index placeholder values to get only actual matches
                                    setMatched = condense(setMatched);
                                }
    
                                // Add matches to results
                                push.apply(results, setMatched);
    
                                // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                if (outermost && !seed && setMatched.length > 0 &&
                                    (matchedCount + setMatchers.length) > 1) {
    
                                    Sizzle.uniqueSort(results);
                                }
                            }
    
                            // Override manipulation of globals by nested matchers
                            if (outermost) {
                                dirruns = dirrunsUnique;
                                outermostContext = contextBackup;
                            }
    
                            return unmatched;
                        };
    
                    return bySet ?
                        markFunction(superMatcher) :
                        superMatcher;
                }
    
                compile = Sizzle.compile = function (selector, match /* Internal Use Only */ ) {
                    var i,
                        setMatchers = [],
                        elementMatchers = [],
                        cached = compilerCache[selector + " "];
    
                    if (!cached) {
                        // Generate a function of recursive functions that can be used to check each element
                        if (!match) {
                            match = tokenCache(selector);
                        }
                        i = match.length;
                        while (i--) {
                            cached = matcherFromTokens(match[i]);
                            if (cached[expando]) {
                                setMatchers.push(cached);
                            } else {
                                elementMatchers.push(cached);
                            }
                        }
    
                        // Cache the compiled function
                        cached = compilerCache(
                            selector,
                            matcherFromGroupMatchers(elementMatchers, setMatchers)
                        );
    
                        // Save selector and tokenization
                        cached.selector = selector;
                    }
                    return cached;
                };
    
                /**
                 * A low-level selection function that works with Sizzle's compiled
                 *  selector functions
                 * @param {String|Function} selector A selector or a pre-compiled
                 *  selector function built with Sizzle.compile
                 * @param {Element} context
                 * @param {Array} [results]
                 * @param {Array} [seed] A set of elements to match against
                 */
                select = Sizzle.select = function (selector, context, results, seed) {
                    var i, tokens, token, type, find,
                        compiled = typeof selector === "function" && selector,
                        match = !seed && tokenCache((selector = compiled.selector || selector));
    
                    results = results || [];
    
                    // Try to minimize operations if there is only one selector in the list and no seed
                    // (the latter of which guarantees us context)
                    if (match.length === 1) {
    
                        // Reduce context if the leading compound selector is an ID
                        tokens = match[0] = match[0].slice(0);
                        if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                            context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
    
                            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                            if (!context) {
                                return results;
    
                                // Precompiled matchers will still verify ancestry, so step up a level
                            } else if (compiled) {
                                context = context.parentNode;
                            }
    
                            selector = selector.slice(tokens.shift().value.length);
                        }
    
                        // Fetch a seed set for right-to-left matching
                        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                        while (i--) {
                            token = tokens[i];
    
                            // Abort if we hit a combinator
                            if (Expr.relative[(type = token.type)]) {
                                break;
                            }
                            if ((find = Expr.find[type])) {
                                // Search, expanding context for leading sibling combinators
                                if ((seed = find(
                                        token.matches[0].replace(runescape, funescape),
                                        rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                    ))) {
    
                                    // If seed is empty or no tokens remain, we can return early
                                    tokens.splice(i, 1);
                                    selector = seed.length && toSelector(tokens);
                                    if (!selector) {
                                        push.apply(results, seed);
                                        return results;
                                    }
    
                                    break;
                                }
                            }
                        }
                    }
    
                    // Compile and execute a filtering function if one is not provided
                    // Provide `match` to avoid retokenization if we modified the selector above
                    (compiled || compile(selector, match))(
                        seed,
                        context,
                        !documentIsHTML,
                        results,
                        !context || rsibling.test(selector) && testContext(context.parentNode) || context
                    );
                    return results;
                };
    
                // One-time assignments
    
                // Sort stability
                support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    
                // Support: Chrome 14-35+
                // Always assume duplicates if they aren't passed to the comparison function
                support.detectDuplicates = !!hasDuplicate;
    
                // Initialize against the default document
                setDocument();
    
                // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                // Detached nodes confoundingly follow *each other*
                support.sortDetached = assert(function (div1) {
                    // Should return 1, but returns 4 (following)
                    return div1.compareDocumentPosition(document.createElement("div")) & 1;
                });
    
                // Support: IE<8
                // Prevent attribute/property "interpolation"
                // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                if (!assert(function (div) {
                        div.innerHTML = "<a href='#'></a>";
                        return div.firstChild.getAttribute("href") === "#";
                    })) {
                    addHandle("type|href|height|width", function (elem, name, isXML) {
                        if (!isXML) {
                            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                        }
                    });
                }
    
                // Support: IE<9
                // Use defaultValue in place of getAttribute("value")
                if (!support.attributes || !assert(function (div) {
                        div.innerHTML = "<input/>";
                        div.firstChild.setAttribute("value", "");
                        return div.firstChild.getAttribute("value") === "";
                    })) {
                    addHandle("value", function (elem, name, isXML) {
                        if (!isXML && elem.nodeName.toLowerCase() === "input") {
                            return elem.defaultValue;
                        }
                    });
                }
    
                // Support: IE<9
                // Use getAttributeNode to fetch booleans when getAttribute lies
                if (!assert(function (div) {
                        return div.getAttribute("disabled") == null;
                    })) {
                    addHandle(booleans, function (elem, name, isXML) {
                        var val;
                        if (!isXML) {
                            return elem[name] === true ? name.toLowerCase() :
                                (val = elem.getAttributeNode(name)) && val.specified ?
                                val.value :
                                null;
                        }
                    });
                }
    
                return Sizzle;
    
            })(window);
    
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
    
        // Deprecated
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;
    
        var dir = function (elem, dir, until) {
            var matched = [],
                truncate = until !== undefined;
    
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        };
    
        var siblings = function (n, elem) {
            var matched = [];
    
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
    
            return matched;
        };
    
        var rneedsContext = jQuery.expr.match.needsContext;
    
        var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);
    
        var risSimple = /^.[^:#\[\.,]*$/;
    
        // Implement the identical functionality for filter and not
        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier)) {
                return jQuery.grep(elements, function (elem, i) {
                    /* jshint -W018 */
                    return !!qualifier.call(elem, i, elem) !== not;
                });
            }
    
            if (qualifier.nodeType) {
                return jQuery.grep(elements, function (elem) {
                    return (elem === qualifier) !== not;
                });
            }
    
            if (typeof qualifier === "string") {
                if (risSimple.test(qualifier)) {
                    return jQuery.filter(qualifier, elements, not);
                }
    
                qualifier = jQuery.filter(qualifier, elements);
            }
    
            return jQuery.grep(elements, function (elem) {
                return (jQuery.inArray(elem, qualifier) >= 0) !== not;
            });
        }
    
        jQuery.filter = function (expr, elems, not) {
            var elem = elems[0];
    
            if (not) {
                expr = ":not(" + expr + ")";
            }
    
            return elems.length === 1 && elem.nodeType === 1 ?
                jQuery.find.matchesSelector(elem, expr) ? [elem] : [] :
                jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                    return elem.nodeType === 1;
                }));
        };
    
        jQuery.fn.extend({
            find: function (selector) {
                var i, ret = [],
                    self = this,
                    len = self.length;
    
                if (typeof selector !== "string") {
                    return this.pushStack(jQuery(selector).filter(function () {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(self[i], this)) {
                                return true;
                            }
                        }
                    }));
                }
    
                for (i = 0; i < len; i++) {
                    jQuery.find(selector, self[i], ret);
                }
    
                // Needed because $( selector, context ) becomes $( context ).find( selector )
                ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                ret.selector = this.selector ? this.selector + " " + selector : selector;
                return ret;
            },
            filter: function (selector) {
                return this.pushStack(winnow(this, selector || [], false));
            },
            not: function (selector) {
                return this.pushStack(winnow(this, selector || [], true));
            },
            is: function (selector) {
                return !!winnow(
                    this,
    
                    // If this is a positional/relative selector, check membership in the returned set
                    // so $("p:first").is("p:last") won't return true for a doc with two "p".
                    typeof selector === "string" && rneedsContext.test(selector) ?
                    jQuery(selector) :
                    selector || [],
                    false
                ).length;
            }
        });
    
        // Initialize a jQuery object
    
        // A central reference to the root jQuery(document)
        var rootjQuery,
    
            // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            // Strict HTML recognition (#11290: must start with <)
            // Shortcut simple #id case for speed
            rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    
            init = jQuery.fn.init = function (selector, context, root) {
                var match, elem;
    
                // HANDLE: $(""), $(null), $(undefined), $(false)
                if (!selector) {
                    return this;
                }
    
                // Method init() accepts an alternate rootjQuery
                // so migrate can support jQuery.sub (gh-2101)
                root = root || rootjQuery;
    
                // Handle HTML strings
                if (typeof selector === "string") {
                    if (selector[0] === "<" &&
                        selector[selector.length - 1] === ">" &&
                        selector.length >= 3) {
    
                        // Assume that strings that start and end with <> are HTML and skip the regex check
                        match = [null, selector, null];
    
                    } else {
                        match = rquickExpr.exec(selector);
                    }
    
                    // Match html or make sure no context is specified for #id
                    if (match && (match[1] || !context)) {
    
                        // HANDLE: $(html) -> $(array)
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
    
                            // scripts is true for back-compat
                            jQuery.merge(this, jQuery.parseHTML(
                                match[1],
                                context && context.nodeType ? context.ownerDocument || context : document,
                                true
                            ));
    
                            // HANDLE: $(html, props)
                            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                for (match in context) {
                                    // Properties of context are called as methods if possible
                                    if (jQuery.isFunction(this[match])) {
                                        this[match](context[match]);
    
                                        // ...and otherwise set as attributes
                                    } else {
                                        this.attr(match, context[match]);
                                    }
                                }
                            }
    
                            return this;
    
                            // HANDLE: $(#id)
                        } else {
                            elem = document.getElementById(match[2]);
    
                            // Check parentNode to catch when Blackberry 4.6 returns
                            // nodes that are no longer in the document (jQuery #6963)
                            if (elem && elem.parentNode) {
                                // Inject the element directly into the jQuery object
                                this.length = 1;
                                this[0] = elem;
                            }
    
                            this.context = document;
                            this.selector = selector;
                            return this;
                        }
    
                        // HANDLE: $(expr, $(...))
                    } else if (!context || context.jquery) {
                        return (context || root).find(selector);
    
                        // HANDLE: $(expr, context)
                        // (which is just equivalent to: $(context).find(expr)
                    } else {
                        return this.constructor(context).find(selector);
                    }
    
                    // HANDLE: $(DOMElement)
                } else if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
    
                    // HANDLE: $(function)
                    // Shortcut for document ready
                } else if (jQuery.isFunction(selector)) {
                    return typeof root.ready !== "undefined" ?
                        root.ready(selector) :
                        // Execute immediately if ready is not present
                        selector(jQuery);
                }
    
                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }
    
                return jQuery.makeArray(selector, this);
            };
    
        // Give the init function the jQuery prototype for later instantiation
        init.prototype = jQuery.fn;
    
        // Initialize central reference
        rootjQuery = jQuery(document);
    
        var rparentsprev = /^(?:parents|prev(?:Until|All))/,
    
            // Methods guaranteed to produce a unique set when starting from a unique set
            guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };
    
        jQuery.extend({
            dir: function (elem, dir, until) {
                var matched = [],
                    truncate = until !== undefined;
    
                while ((elem = elem[dir]) && elem.nodeType !== 9) {
                    if (elem.nodeType === 1) {
                        if (truncate && jQuery(elem).is(until)) {
                            break;
                        }
                        matched.push(elem);
                    }
                }
                return matched;
            },
    
            sibling: function (n, elem) {
                var matched = [];
    
                for (; n; n = n.nextSibling) {
                    if (n.nodeType === 1 && n !== elem) {
                        matched.push(n);
                    }
                }
    
                return matched;
            }
        });
    
        jQuery.fn.extend({
            has: function (target) {
                var i,
                    targets = jQuery(target, this),
                    len = targets.length;
    
                return this.filter(function () {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(this, targets[i])) {
                            return true;
                        }
                    }
                });
            },
    
            closest: function (selectors, context) {
                var cur,
                    i = 0,
                    l = this.length,
                    matched = [],
                    pos = rneedsContext.test(selectors) || typeof selectors !== "string" ?
                    jQuery(selectors, context || this.context) :
                    0;
    
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        // Always skip document fragments
                        if (cur.nodeType < 11 && (pos ?
                                pos.index(cur) > -1 :
    
                                // Don't pass non-elements to Sizzle
                                cur.nodeType === 1 &&
                                jQuery.find.matchesSelector(cur, selectors))) {
    
                            matched.push(cur);
                            break;
                        }
                    }
                }
    
                return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
            },
    
            // Determine the position of an element within the set
            index: function (elem) {
                // No argument, return index in parent
                if (!elem) {
                    return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
                }
    
                // index in selector
                if (typeof elem === "string") {
                    return jQuery.inArray(this[0], jQuery(elem));
                }
    
                // Locate the position of the desired element
                return jQuery.inArray(
                    // If it receives a jQuery object, the first element is used
                    elem.jquery ? elem[0] : elem, this);
            },
    
            add: function (selector, context) {
                return this.pushStack(
                    jQuery.uniqueSort(
                        jQuery.merge(this.get(), jQuery(selector, context))
                    )
                );
            },
    
            addBack: function (selector) {
                return this.add(selector == null ?
                    this.prevObject : this.prevObject.filter(selector)
                );
            }
        });
    
        function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {}
            return cur;
        }
    
        jQuery.each({
            parent: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function (elem) {
                return dir(elem, "parentNode");
            },
            parentsUntil: function (elem, i, until) {
                return dir(elem, "parentNode", until);
            },
            next: function (elem) {
                return sibling(elem, "nextSibling");
            },
            prev: function (elem) {
                return sibling(elem, "previousSibling");
            },
            nextAll: function (elem) {
                return dir(elem, "nextSibling");
            },
            prevAll: function (elem) {
                return dir(elem, "previousSibling");
            },
            nextUntil: function (elem, i, until) {
                return dir(elem, "nextSibling", until);
            },
            prevUntil: function (elem, i, until) {
                return dir(elem, "previousSibling", until);
            },
            siblings: function (elem) {
                return siblings((elem.parentNode || {}).firstChild, elem);
            },
            children: function (elem) {
                return siblings(elem.firstChild);
            },
            contents: function (elem) {
                return elem.contentDocument || jQuery.merge([], elem.childNodes);
            }
        }, function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
                var ret = jQuery.map(this, fn, until);
    
                if (name.slice(-5) !== "Until") {
                    selector = until;
                }
    
                if (selector && typeof selector === "string") {
                    ret = jQuery.filter(selector, ret);
                }
    
                if (this.length > 1) {
                    // Remove duplicates
                    if (!guaranteedUnique[name]) {
                        ret = jQuery.uniqueSort(ret);
                    }
    
                    // Reverse order for parents* and prev-derivatives
                    if (rparentsprev.test(name)) {
                        ret = ret.reverse();
                    }
                }
    
                return this.pushStack(ret);
            };
        });
        var rnotwhite = (/\S+/g);
    
        // Convert String-formatted options into Object-formatted ones
        function createOptions(options) {
            var object = {};
            jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                object[flag] = true;
            });
            return object;
        }
    
        /*
         * Create a callback list using the following parameters:
         *
         *	options: an optional list of space-separated options that will change how
         *			the callback list behaves or a more traditional option object
         *
         * By default a callback list will act like an event callback list and can be
         * "fired" multiple times.
         *
         * Possible options:
         *
         *	once:			will ensure the callback list can only be fired once (like a Deferred)
         *
         *	memory:			will keep track of previous values and will call any callback added
         *					after the list has been fired right away with the latest "memorized"
         *					values (like a Deferred)
         *
         *	unique:			will ensure a callback can only be added once (no duplicate in the list)
         *
         *	stopOnFalse:	interrupt callings when a callback returns false
         *
         */
        jQuery.Callbacks = function (options) {
    
            // Convert options from String-formatted to Object-formatted if needed
            // (we check in cache first)
            options = typeof options === "string" ?
                createOptions(options) :
                jQuery.extend({}, options);
    
            var // Flag to know if list is currently firing
                firing,
    
                // Last fire value for non-forgettable lists
                memory,
    
                // Flag to know if list was already fired
                fired,
    
                // Flag to prevent firing
                locked,
    
                // Actual callback list
                list = [],
    
                // Queue of execution data for repeatable lists
                queue = [],
    
                // Index of currently firing callback (modified by add/remove as needed)
                firingIndex = -1,
    
                // Fire callbacks
                fire = function () {
    
                    // Enforce single-firing
                    locked = locked || options.once;
    
                    // Execute callbacks for all pending executions,
                    // respecting firingIndex overrides and runtime changes
                    fired = firing = true;
                    for (; queue.length; firingIndex = -1) {
                        memory = queue.shift();
                        while (++firingIndex < list.length) {
    
                            // Run callback and check for early termination
                            if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                                options.stopOnFalse) {
    
                                // Jump to end and forget the data so .add doesn't re-fire
                                firingIndex = list.length;
                                memory = false;
                            }
                        }
                    }
    
                    // Forget the data if we're done with it
                    if (!options.memory) {
                        memory = false;
                    }
    
                    firing = false;
    
                    // Clean up if we're done firing for good
                    if (locked) {
    
                        // Keep an empty list if we have data for future add calls
                        if (memory) {
                            list = [];
    
                            // Otherwise, this object is spent
                        } else {
                            list = "";
                        }
                    }
                },
    
                // Actual Callbacks object
                self = {
    
                    // Add a callback or a collection of callbacks to the list
                    add: function () {
                        if (list) {
    
                            // If we have memory from a past run, we should fire after adding
                            if (memory && !firing) {
                                firingIndex = list.length - 1;
                                queue.push(memory);
                            }
    
                            (function add(args) {
                                jQuery.each(args, function (_, arg) {
                                    if (jQuery.isFunction(arg)) {
                                        if (!options.unique || !self.has(arg)) {
                                            list.push(arg);
                                        }
                                    } else if (arg && arg.length && jQuery.type(arg) !== "string") {
    
                                        // Inspect recursively
                                        add(arg);
                                    }
                                });
                            })(arguments);
    
                            if (memory && !firing) {
                                fire();
                            }
                        }
                        return this;
                    },
    
                    // Remove a callback from the list
                    remove: function () {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
    
                                // Handle firing indexes
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        });
                        return this;
                    },
    
                    // Check if a given callback is in the list.
                    // If no argument is given, return whether or not list has callbacks attached.
                    has: function (fn) {
                        return fn ?
                            jQuery.inArray(fn, list) > -1 :
                            list.length > 0;
                    },
    
                    // Remove all callbacks from the list
                    empty: function () {
                        if (list) {
                            list = [];
                        }
                        return this;
                    },
    
                    // Disable .fire and .add
                    // Abort any current/pending executions
                    // Clear all callbacks and values
                    disable: function () {
                        locked = queue = [];
                        list = memory = "";
                        return this;
                    },
                    disabled: function () {
                        return !list;
                    },
    
                    // Disable .fire
                    // Also disable .add unless we have memory (since it would have no effect)
                    // Abort any pending executions
                    lock: function () {
                        locked = true;
                        if (!memory) {
                            self.disable();
                        }
                        return this;
                    },
                    locked: function () {
                        return !!locked;
                    },
    
                    // Call all callbacks with the given context and arguments
                    fireWith: function (context, args) {
                        if (!locked) {
                            args = args || [];
                            args = [context, args.slice ? args.slice() : args];
                            queue.push(args);
                            if (!firing) {
                                fire();
                            }
                        }
                        return this;
                    },
    
                    // Call all the callbacks with the given arguments
                    fire: function () {
                        self.fireWith(this, arguments);
                        return this;
                    },
    
                    // To know if the callbacks have already been called at least once
                    fired: function () {
                        return !!fired;
                    }
                };
    
            return self;
        };
    
        jQuery.extend({
    
            Deferred: function (func) {
                var tuples = [
                        // action, add listener, listener list, final state
                        ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                        ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                        ["notify", "progress", jQuery.Callbacks("memory")]
                    ],
                    state = "pending",
                    promise = {
                        state: function () {
                            return state;
                        },
                        always: function () {
                            deferred.done(arguments).fail(arguments);
                            return this;
                        },
                        then: function ( /* fnDone, fnFail, fnProgress */) {
                            var fns = arguments;
                            return jQuery.Deferred(function (newDefer) {
                                jQuery.each(tuples, function (i, tuple) {
                                    var fn = jQuery.isFunction(fns[i]) && fns[i];
                                    // deferred[ done | fail | progress ] for forwarding actions to newDefer
                                    deferred[tuple[1]](function () {
                                        var returned = fn && fn.apply(this, arguments);
                                        if (returned && jQuery.isFunction(returned.promise)) {
                                            returned.promise()
                                                .progress(newDefer.notify)
                                                .done(newDefer.resolve)
                                                .fail(newDefer.reject);
                                        } else {
                                            newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        // Get a promise for this deferred
                        // If obj is provided, the promise aspect is added to the object
                        promise: function (obj) {
                            return obj != null ? jQuery.extend(obj, promise) : promise;
                        }
                    },
                    deferred = {};
    
                // Keep pipe for back-compat
                promise.pipe = promise.then;
    
                // Add list-specific methods
                jQuery.each(tuples, function (i, tuple) {
                    var list = tuple[2],
                        stateString = tuple[3];
    
                    // promise[ done | fail | progress ] = list.add
                    promise[tuple[1]] = list.add;
    
                    // Handle state
                    if (stateString) {
                        list.add(function () {
                            // state = [ resolved | rejected ]
                            state = stateString;
    
                            // [ reject_list | resolve_list ].disable; progress_list.lock
                        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                    }
    
                    // deferred[ resolve | reject | notify ] = list.fire
                    deferred[tuple[0]] = list.fire;
                    deferred[tuple[0] + "With"] = list.fireWith;
                });
    
                // Make the deferred a promise
                promise.promise(deferred);
    
                // Call given func if any
                if (func) {
                    func.call(deferred, deferred);
                }
    
                // All done!
                return deferred;
            },
    
            // Deferred helper
            when: function (subordinate /* , ..., subordinateN */ ) {
                var i = 0,
                    resolveValues = slice.call(arguments),
                    length = resolveValues.length,
    
                    // the count of uncompleted subordinates
                    remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
    
                    // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
                    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
    
                    // Update function for both resolve and progress values
                    updateFunc = function (i, contexts, values) {
                        return function (value) {
                            contexts[i] = this;
                            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                            if (values === progressValues) {
                                deferred.notifyWith(contexts, values);
                            } else if (!(--remaining)) {
                                deferred.resolveWith(contexts, values);
                            }
                        };
                    },
    
                    progressValues, progressContexts, resolveContexts;
    
                // add listeners to Deferred subordinates; treat others as resolved
                if (length > 1) {
                    progressValues = new Array(length);
                    progressContexts = new Array(length);
                    resolveContexts = new Array(length);
                    for (; i < length; i++) {
                        if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                            resolveValues[i].promise()
                                .progress(updateFunc(i, progressContexts, progressValues))
                                .done(updateFunc(i, resolveContexts, resolveValues))
                                .fail(deferred.reject);
                        } else {
                            --remaining;
                        }
                    }
                }
    
                // if we're not waiting on anything, resolve the master
                if (!remaining) {
                    deferred.resolveWith(resolveContexts, resolveValues);
                }
    
                return deferred.promise();
            }
        });
        var readyList;
    
        jQuery.fn.ready = function (fn) {
            // Add the callback
            jQuery.ready.promise().done(fn);
    
            return this;
        };
    
        jQuery.extend({
            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,
    
            // A counter to track how many items to wait for before the ready event fires. See #6781
            readyWait: 1,
    
            // Hold (or release) the ready event
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },
    
            // Handle when the DOM is ready
            ready: function (wait) {
    
                // Abort if there are pending holds or we're already ready
                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                    return;
                }
    
                // Remember that the DOM is ready
                jQuery.isReady = true;
    
                // If a normal DOM Ready event fired, decrement, and wait if need be
                if (wait !== true && --jQuery.readyWait > 0) {
                    return;
                }
    
                // If there are functions bound, to execute
                readyList.resolveWith(document, [jQuery]);
            }
        });
    
        /**
         * The ready event handler and self cleanup method
         */
        function completed() {
            document.removeEventListener("DOMContentLoaded", completed);
            window.removeEventListener("load", completed);
            jQuery.ready();
        }
    
        jQuery.ready.promise = function (obj) {
            if (!readyList) {
    
                readyList = jQuery.Deferred();
    
                // Catch cases where $(document).ready() is called
                // after the browser event has already occurred.
                // Support: IE9-10 only
                // Older IE sometimes signals "interactive" too soon
                if (document.readyState === "complete" ||
                    (document.readyState !== "loading" && !document.documentElement.doScroll)) {
    
                    // Handle it asynchronously to allow scripts the opportunity to delay ready
                    window.setTimeout(jQuery.ready);
    
                    // Standards-based browsers support DOMContentLoaded
                } else {
                    // Use the handy event callback
                    document.addEventListener("DOMContentLoaded", completed);
    
                    // A fallback to window.onload, that will always work
                    window.addEventListener("load", completed);
                }
            }
            return readyList.promise(obj);
        };
    
        // Kick off the DOM ready check even if the user does not
        jQuery.ready.promise();
    })(window);
    // Define jQuery
var jQuery = (function () {
    // Define a local copy of jQuery
    var jQuery = function (selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        return new jQuery.fn.init(selector, context);
    };

    // jQuery version
    jQuery.fn = jQuery.prototype = {
        jquery: "3.0.0",
        constructor: jQuery,
        // Start with an empty selector
        selector: "",
        // The default length of a jQuery object is 0
        length: 0,
        // Initialize the jQuery object
        init: function (selector, context) {
            // Handle $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }
            // Handle $(document)
            if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }
            // Handle HTML strings
            if (typeof selector === "string") {
                // Handle HTML strings
                // ...
            }
        },
        // Other methods...
    };

    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;

    // Add jQuery.extend and jQuery.fn.extend
    jQuery.extend = jQuery.fn.extend = function () {
        // Merge code...
    };

    // Add jQuery.ready
    jQuery.ready = function (callback) {
        // Ready code...
    };

    // Add jQuery.fn.ready
    jQuery.fn.ready = function (callback) {
        jQuery.ready(callback);
        return this;
    };

    // Add jQuery.isReady
    jQuery.isReady = false;

    // Add jQuery.readyWait
    jQuery.readyWait = 0;

    // Add jQuery.holdReady
    jQuery.holdReady = function (hold) {
        // HoldReady code...
    };

    // Add other jQuery methods...

    // Return the jQuery object
    return jQuery;
})();

// Expose jQuery and $ to the global object
window.jQuery = window.$ = jQuery;
// Define jQuery
var jQuery = (function () {
    // Define a local copy of jQuery
    var jQuery = function (selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        return new jQuery.fn.init(selector, context);
    };

    // jQuery version
    jQuery.fn = jQuery.prototype = {
        jquery: "3.0.0",
        constructor: jQuery,
        // Start with an empty selector
        selector: "",
        // The default length of a jQuery object is 0
        length: 0,
        // Initialize the jQuery object
        init: function (selector, context) {
            // Handle $(null), $(undefined), $(false)
            if (!selector) {
                return this;
            }
            // Handle $(document)
            if (selector.nodeType) {
                this.context = this[0] = selector;
                this.length = 1;
                return this;
            }
            // Handle HTML strings
            if (typeof selector === "string") {
                // Handle HTML strings
                // ...
            }
        },
        // Other methods...
    };

    // Give the init function the jQuery prototype for later instantiation
    jQuery.fn.init.prototype = jQuery.fn;

    // Add jQuery.extend and jQuery.fn.extend
    jQuery.extend = jQuery.fn.extend = function () {
        // Merge code...
    };

    // Add jQuery.ready
    jQuery.ready = function (callback) {
        // Ready code...
    };

    // Add jQuery.fn.ready
    jQuery.fn.ready = function (callback) {
        jQuery.ready(callback);
        return this;
    };

    // Add jQuery.isReady
    jQuery.isReady = false;

    // Add jQuery.readyWait
    jQuery.readyWait = 0;

    // Add jQuery.holdReady
    jQuery.holdReady = function (hold) {
        // HoldReady code...
    };

    // Add other jQuery methods...

    // Return the jQuery object
    return jQuery;
})();

// Expose jQuery and $ to the global object
window.jQuery = window.$ = jQuery;
// Code to convert to jQuery 3

// Define variables
var p = document.createElement("div"),
    q = document.documentElement;
var b = {
    boxModel: b.boxModel = q.compatMode === "CSS1Compat"
};
var i = p.cloneNode(true),
    g = document.createElement("div"),
    h = g.cloneNode(true);

// Define try-catch block
try {
    delete p.test;
} catch (r) {
    b.deleteExpando = false;
}

// Add event listener for non-standard browsers
if (!p.addEventListener && p.attachEvent && p.fireEvent) {
    p.attachEvent("onclick", function () {
        b.noCloneEvent = false;
    });
    p.cloneNode(true).fireEvent("onclick");
}

// Create elements for testing
var i = document.createElement("input");
i.value = "t";
i.setAttribute("type", "radio");
i.setAttribute("checked", "checked");
i.setAttribute("name", "t");
p.appendChild(i);

// Create document fragment
var j = document.createDocumentFragment();
j.appendChild(p.lastChild);

// Add properties to b object
var k = {};
for (var n in {
    submit: 1,
    change: 1,
    focusin: 1
}) {
    var m = "on" + n,
        o = m in p;
    if (!o) {
        p.setAttribute(m, "return;");
        o = typeof p[m] == "function";
    }
    k[n + "Bubbles"] = o;
}

// Remove elements
j.removeChild(p);
j = g = h = p = i = null;

// Add function to execute after the document is ready
jQuery(function () {
    var d, e, g, h, i, j, l, m, n, q, r, s, t, u = document.getElementsByTagName("body")[0];
    if (!u) return;
    m = 1;
    t = "padding:0;margin:0;border:";
    r = "position:absolute;top:0;left:0;width:1px;height:1px;";
    s = t + "0;visibility:hidden;";
    n = "style='" + r + t + "5px solid #000;";
    q = "<div " + n + "display:block;'><div style='" + t + "0;display:block;overflow:hidden;'></div></div>" + "<table " + n + "' cellpadding='0' cellspacing='0'>" + "<tr><td></td></tr></table>";
    d = document.createElement("div");
    d.style.cssText = s + "width:0;height:0;position:static;top:0;margin-top:" + m + "px";
    u.insertBefore(d, u.firstChild);
    p = document.createElement("div");
    d.appendChild(p);
    p.innerHTML = "<table><tr><td style='" + t + "0;display:none'></td><td>t</td></tr></table>";
    k = p.getElementsByTagName("td");
    o = k[0].offsetHeight === 0;
    k[0].style.display = "";
    k[1].style.display = "none";
    b.reliableHiddenOffsets = o && k[0].offsetHeight === 0;
    if (window.getComputedStyle) {
        p.innerHTML = "";
        l = document.createElement("div");
        l.style.width = "0";
        l.style.marginRight = "0";
        p.style.width = "2px";
        p.appendChild(l);
        b.reliableMarginRight = (parseInt((window.getComputedStyle(l, null) || {
            marginRight: 0
        }).marginRight, 10) || 0) === 0;
    }
    if (typeof p.style.zoom != "undefined") {
        p.innerHTML = "";
        p.style.width = p.style.padding = "1px";
        p.style.border = 0;
        p.style.overflow = "hidden";
        p.style.display = "inline";
        p.style.zoom = 1;
        b.inlineBlockNeedsLayout = p.offsetWidth === 3;
        p.style.display = "block";
        p.style.overflow = "visible";
        p.innerHTML = "<div style='width:5px;'></div>";
        b.shrinkWrapBlocks = p.offsetWidth !== 3;
    }
    p.style.cssText = r + s;
    p.innerHTML = q;
    e = p.firstChild;
    g = e.firstChild;
    i = e.nextSibling.firstChild.firstChild;
    j = {
        doesNotAddBorder: g.offsetTop !== 5,
        doesAddBorderForTableAndCells: i.offsetTop === 5
    };
    g.style.position = "fixed";
    g.style.top = "20px";
    j.fixedPosition = g.offsetTop === 20 || g.offsetTop === 15;
    g.style.position = g.style.top = "";
    e.style.overflow = "hidden";
    e.style.position = "relative";
    j.subtractsBorderForOverflowNotVisible = g.offsetTop === -5;
    j.doesNotIncludeMarginInBodyOffset = u.offsetTop !== m;
    if (window.getComputedStyle) {
        p.style.marginTop = "1%";
        b.pixelMargin = (window.getComputedStyle(p, null) || {
            marginTop: 0
        }).marginTop !== "1%";
    }
    if (typeof d.style.zoom != "undefined") {
        d.style.zoom = 1;
    }
    u.removeChild(d);
    l = p = d = null;
    jQuery.extend(b, j);
});

// Define regular expressions
var j = /^(?:\{.*\}|\[.*\])$/,
    k = /([A-Z])/g;

// Extend jQuery object with cache-related methods
jQuery.extend({
    cache: {},
    uuid: 0,
    expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),
    noData: {
        embed: true,
        object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
        applet: true
    },
    hasData: function (elem) {
        var id = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
        return !!id && !isEmptyDataObject(jQuery.cache[id]);
    },
    data: function (elem, name, data) {
        // Implementation of data method
    },
    removeData: function (elem, name) {
        // Implementation of removeData method
    },
    _data: function (elem, name, data) {
        return jQuery.data(elem, name, data, true);
    },
    acceptData: function (elem) {
        // Implementation of acceptData method
    }
});

// Extend jQuery.fn object with data-related methods
jQuery.fn.extend({
    data: function (key, value) {
        // Implementation of data method
    },
    removeData: function (key) {
        // Implementation of removeData method
    }
});

// Define helper functions
function isEmptyDataObject(obj) {
    // Implementation of isEmptyDataObject method
}

// Return jQuery object
jQuery;
// Code to convert to jQuery 3

// Define regular expressions
var o = /[\n\t\r]/g,
    p = /\s+/,
    q = /\r/g;

// Extend jQuery.fn object with attribute-related methods
jQuery.fn.extend({
    attr: function (name, value) {
        return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
        return this.each(function () {
            jQuery.removeAttr(this, name);
        });
    },
    prop: function (name, value) {
        return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
        name = jQuery.propFix[name] || name;
        return this.each(function () {
            try {
                this[name] = undefined;
                delete this[name];
            } catch (e) {}
        });
    },
    addClass: function (value) {
        var classNames, i, l, elem, className, setClass, c, cl;
        if (jQuery.isFunction(value)) {
            return this.each(function (i) {
                jQuery(this).addClass(value.call(this, i, this.className));
            });
        }
        if (value && typeof value === "string") {
            classNames = value.split(p);
            for (i = 0, l = this.length; i < l; i++) {
                elem = this[i];
                if (elem.nodeType === 1) {
                    if (!elem.className && classNames.length === 1) {
                        elem.className = value;
                    } else {
                        setClass = " " + elem.className + " ";
                        for (c = 0, cl = classNames.length; c < cl; c++) {
                            className = classNames[c];
                            if (setClass.indexOf(" " + className + " ") < 0) {
                                setClass += className + " ";
                            }
                        }
                        elem.className = jQuery.trim(setClass);
                    }
                }
            }
        }
        return this;
    },
    removeClass: function (value) {
        var classNames, i, l, elem, className, c, cl;
        if (jQuery.isFunction(value)) {
            return this.each(function (i) {
                jQuery(this).removeClass(value.call(this, i, this.className));
            });
        }
        if ((value && typeof value === "string") || value === undefined) {
            classNames = (value || "").split(p);
            for (i = 0, l = this.length; i < l; i++) {
                elem = this[i];
                if (elem.nodeType === 1 && elem.className) {
                    if (value) {
                        className = (" " + elem.className + " ").replace(o, " ");
                        for (c = 0, cl = classNames.length; c < cl; c++) {
                            className = className.replace(" " + classNames[c] + " ", " ");
                        }
                        elem.className = jQuery.trim(className);
                    } else {
                        elem.className = "";
                    }
                }
            }
        }
        return this;
    },
    toggleClass: function (value, stateVal) {
        var type = typeof value,
            isValidValue, className, i, self, classNames, state, classNameSet, classNamesSet;
        if (typeof stateVal === "boolean" && type === "string") {
            return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        if (jQuery.isFunction(value)) {
            return this.each(function (i) {
                jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
            });
        }
        return this.each(function () {
            if (type === "string") {
                self = jQuery(this);
                classNames = value.split(p);
                state = stateVal;
                i = 0;
                while ((className = classNames[i++])) {
                    isValidValue = stateVal !== undefined ? stateVal : !self.hasClass(className);
                    if (isValidValue) {
                        self.addClass(className);
                    } else {
                        self.removeClass(className);
                    }
                }
            } else if (type === "undefined" || type === "boolean") {
                classNameSet = jQuery._data(this, "__className__");
                if (!classNameSet) {
                    classNameSet = jQuery._data(this, "__className__", this.className);
                }
                if (this.className) {
                    jQuery._data(this, "__className__", "");
                }
                this.className = classNameSet || value === false ? "" : classNameSet;
            }
        });
    },
    hasClass: function (selector) {
        var className = " " + selector + " ",
            i = 0,
            l = this.length;
        for (; i < l; i++) {
            if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(o, " ").indexOf(className) > -1) {
                return true;
            }
        }
        return false;
    },
    val: function (value) {
        var hooks, ret, isFunction, elem = this[0];
        if (!arguments.length) {
            if (elem) {
                hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                    return ret;
                }
                ret = elem.value;
                return typeof ret === "string" ? ret.replace(q, "") : ret == null ? "" : ret;
            }
            return;
        }
        isFunction = jQuery.isFunction(value);
        return this.each(function (i) {
            var val, self = jQuery(this);
            if (this.nodeType !== 1) {
                return;
            }
            if (isFunction) {
                val = value.call(this, i, self.val());
            } else {
                val = value;
            }
            if (val == null) {
                val = "";
            } else if (typeof val === "number") {
                val += "";
            } else if (jQuery.isArray(val)) {
                val = jQuery.map(val, function (value) {
                    return value == null ? "" : value + "";
                });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                this.value = val;
            }
        });
    }
});

// Extend jQuery object with attribute-related methods
jQuery.extend({
    valHooks: {
        option: {
            get: function (elem) {
                var val = jQuery.attr(elem, "value");
                return val != null ? val : elem.text;
            }
        },
        select: {
            get: function (elem) {
                var value, option, options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === "select-one" || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ? max : one ? index : 0;
                for (; i < max; i++) {
                    option = options[i];
                    if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                        value = jQuery(option).val();
                        if (one) {
                            return value;
                        }
                        values.push(value);
                    }
                }
                return values;
            },
            set: function (elem, value) {
                var optionSet, option, options = elem.options,
                    values = jQuery.makeArray(value),
                    i = options.length;
                while (i--) {
                    option = options[i];
                    if ((option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0)) {
                        optionSet = true;
                    }
                }
                if (!optionSet) {
                    elem.selectedIndex = -1;
                }
                return values;
            }
        }
    }
});
// Convert the code to jQuery 3

// Define regular expressions
var o = /[\n\t\r]/g,
    p = /\s+/,
    q = /\r/g;

// Extend jQuery.fn object with attribute-related methods
jQuery.fn.extend({
    attr: function(name, value) {
        return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
        return this.each(function() {
            jQuery.removeAttr(this, name);
        });
    },
    prop: function(name, value) {
        return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
        return this.each(function() {
            delete this[jQuery.propFix[name] || name];
        });
    },
    addClass: function(value) {
        var classNames, i, l, elem, className, setClass, c, cl;
        if (jQuery.isFunction(value)) {
            return this.each(function(i) {
                jQuery(this).addClass(value.call(this, i, this.className));
            });
        }
        if (value && typeof value === "string") {
            classNames = value.split(p);
            for (i = 0, l = this.length; i < l; i++) {
                elem = this[i];
                if (elem.nodeType === 1) {
                    if (!elem.className && classNames.length === 1) {
                        elem.className = value;
                    } else {
                        setClass = " " + elem.className + " ";
                        for (c = 0, cl = classNames.length; c < cl; c++) {
                            className = classNames[c];
                            if (setClass.indexOf(" " + className + " ") < 0) {
                                setClass += className + " ";
                            }
                        }
                        elem.className = jQuery.trim(setClass);
                    }
                }
            }
        }
        return this;
    },
    removeClass: function(value) {
        var classNames, i, l, elem, className, c, cl;
        if (jQuery.isFunction(value)) {
            return this.each(function(i) {
                jQuery(this).removeClass(value.call(this, i, this.className));
            });
        }
        if ((value && typeof value === "string") || value === undefined) {
            classNames = (value || "").split(p);
            for (i = 0, l = this.length; i < l; i++) {
                elem = this[i];
                if (elem.nodeType === 1 && elem.className) {
                    if (value) {
                        className = (" " + elem.className + " ").replace(o, " ");
                        for (c = 0, cl = classNames.length; c < cl; c++) {
                            className = className.replace(" " + classNames[c] + " ", " ");
                        }
                        elem.className = jQuery.trim(className);
                    } else {
                        elem.className = "";
                    }
                }
            }
        }
        return this;
    },
    toggleClass: function(value, stateVal) {
        var type = typeof value,
            isValidValue, className, i, self, classNames, state, classNameSet, classNamesSet;
        if (typeof stateVal === "boolean" && type === "string") {
            return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        if (jQuery.isFunction(value)) {
            return this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
            });
        }
        return this.each(function() {
            if (type === "string") {
                self = jQuery(this);
                classNames = value.split(p);
                state = stateVal;
                i = 0;
                while ((className = classNames[i++])) {
                    isValidValue = stateVal !== undefined ? stateVal : !self.hasClass(className);
                    if (isValidValue) {
                        self.addClass(className);
                    } else {
                        self.removeClass(className);
                    }
                }
            } else if (type === "undefined" || type === "boolean") {
                classNameSet = jQuery._data(this, "__className__");
                if (!classNameSet) {
                    classNameSet = jQuery._data(this, "__className__", this.className);
                }
                if (this.className) {
                    jQuery._data(this, "__className__", "");
                }
                this.className = classNameSet || value === false ? "" : classNameSet;
            }
        });
    },
    hasClass: function(selector) {
        var className = " " + selector + " ",
            i = 0,
            l = this.length;
        for (; i < l; i++) {
            if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(o, " ").indexOf(className) > -1) {
                return true;
            }
        }
        return false;
    },
    val: function(value) {
        var hooks, ret, isFunction, elem = this[0];
        if (!arguments.length) {
            if (elem) {
                hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                    return ret;
                }
                ret = elem.value;
                return typeof ret === "string" ? ret.replace(q, "") : ret == null ? "" : ret;
            }
            return;
        }
        isFunction = jQuery.isFunction(value);
        return this.each(function(i) {
            var val, self = jQuery(this);
            if (this.nodeType !== 1) {
                return;
            }
            if (isFunction) {
                val = value.call(this, i, self.val());
            } else {
                val = value;
            }
            if (val == null) {
                val = "";
            } else if (typeof val === "number") {
                val += "";
            } else if (jQuery.isArray(val)) {
                val = jQuery.map(val, function(value) {
                    return value == null ? "" : value + "";
                });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                this.value = val;
            }
        });
    }
});

// Extend jQuery object with attribute-related methods
jQuery.extend({
    valHooks: {
        option: {
            get: function(elem) {
                var val = jQuery.attr(elem, "value");
                return val != null ? val : elem.text;
            }
        },
        select: {
            get: function(elem) {
                var value, option, options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === "select-one" || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ? max : one ? index : 0;
                for (; i < max; i++) {
                    option = options[i];
                    if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                        value = jQuery(option).val();
                        if (one) {
                            return value;
                        }
                        values.push(value);
                    }
                }
                return values;
            },
            set: function(elem, value) {
                var optionSet, option, options = elem.options,
                    values = jQuery.makeArray(value),
                    i = options.length;
                while (i--) {
                    option = options[i];
                    if ((option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0)) {
                        optionSet = true;
                    }
                }
                if (!optionSet) {
                    elem.selectedIndex = -1;
                }
                return values;
            }
        }
    }
});
// Define regular expressions
var o = /[\n\t\r]/g,
    p = /\s+/,
    q = /\r/g;

// Extend jQuery.fn object with attribute-related methods
jQuery.fn.extend({
    attr: function(name, value) {
        return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
        return this.each(function() {
            jQuery.removeAttr(this, name);
        });
    },
    prop: function(name, value) {
        return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
        return this.each(function() {
            delete this[jQuery.propFix[name] || name];
        });
    },
    addClass: function(value) {
        var classNames, i, l, elem, className, setClass, c, cl;
        if (jQuery.isFunction(value)) {
            return this.each(function(i) {
                jQuery(this).addClass(value.call(this, i, this.className));
            });
        }
        if (value && typeof value === "string") {
            classNames = value.split(p);
            for (i = 0, l = this.length; i < l; i++) {
                elem = this[i];
                if (elem.nodeType === 1) {
                    if (!elem.className && classNames.length === 1) {
                        elem.className = value;
                    } else {
                        setClass = " " + elem.className + " ";
                        for (c = 0, cl = classNames.length; c < cl; c++) {
                            className = classNames[c];
                            if (setClass.indexOf(" " + className + " ") < 0) {
                                setClass += className + " ";
                            }
                        }
                        elem.className = jQuery.trim(setClass);
                    }
                }
            }
        }
        return this;
    },
    removeClass: function(value) {
        var classNames, i, l, elem, className, c, cl;
        if (jQuery.isFunction(value)) {
            return this.each(function(i) {
                jQuery(this).removeClass(value.call(this, i, this.className));
            });
        }
        if ((value && typeof value === "string") || value === undefined) {
            classNames = (value || "").split(p);
            for (i = 0, l = this.length; i < l; i++) {
                elem = this[i];
                if (elem.nodeType === 1 && elem.className) {
                    if (value) {
                        className = (" " + elem.className + " ").replace(o, " ");
                        for (c = 0, cl = classNames.length; c < cl; c++) {
                            className = className.replace(" " + classNames[c] + " ", " ");
                        }
                        elem.className = jQuery.trim(className);
                    } else {
                        elem.className = "";
                    }
                }
            }
        }
        return this;
    },
    toggleClass: function(value, stateVal) {
        var type = typeof value,
            isValidValue, className, i, self, classNames, state, classNameSet, classNamesSet;
        if (typeof stateVal === "boolean" && type === "string") {
            return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        if (jQuery.isFunction(value)) {
            return this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
            });
        }
        return this.each(function() {
            if (type === "string") {
                self = jQuery(this);
                classNames = value.split(p);
                state = stateVal;
                i = 0;
                while ((className = classNames[i++])) {
                    isValidValue = stateVal !== undefined ? stateVal : !self.hasClass(className);
                    if (isValidValue) {
                        self.addClass(className);
                    } else {
                        self.removeClass(className);
                    }
                }
            } else if (type === "undefined" || type === "boolean") {
                classNameSet = jQuery._data(this, "__className__");
                if (!classNameSet) {
                    classNameSet = jQuery._data(this, "__className__", this.className);
                }
                if (this.className) {
                    jQuery._data(this, "__className__", "");
                }
                this.className = classNameSet || value === false ? "" : classNameSet;
            }
        });
    },
    hasClass: function(selector) {
        var className = " " + selector + " ",
            i = 0,
            l = this.length;
        for (; i < l; i++) {
            if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(o, " ").indexOf(className) > -1) {
                return true;
            }
        }
        return false;
    },
    val: function(value) {
        var hooks, ret, isFunction, elem = this[0];
        if (!arguments.length) {
            if (elem) {
                hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                    return ret;
                }
                ret = elem.value;
                return typeof ret === "string" ? ret.replace(q, "") : ret == null ? "" : ret;
            }
            return;
        }
        isFunction = jQuery.isFunction(value);
        return this.each(function(i) {
            var val, self = jQuery(this);
            if (this.nodeType !== 1) {
                return;
            }
            if (isFunction) {
                val = value.call(this, i, self.val());
            } else {
                val = value;
            }
            if (val == null) {
                val = "";
            } else if (typeof val === "number") {
                val += "";
            } else if (jQuery.isArray(val)) {
                val = jQuery.map(val, function(value) {
                    return value == null ? "" : value + "";
                });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                this.value = val;
            }
        });
    }
});

// Extend jQuery object with attribute-related methods
jQuery.extend({
    valHooks: {
        option: {
            get: function(elem) {
                var val = jQuery.attr(elem, "value");
                return val != null ? val : elem.text;
            }
        },
        select: {
            get: function(elem) {
                var value, option, options = elem.options,
                    index = elem.selectedIndex,
                    one = elem.type === "select-one" || index < 0,
                    values = one ? null : [],
                    max = one ? index + 1 : options.length,
                    i = index < 0 ? max : one ? index : 0;
                for (; i < max; i++) {
                    option = options[i];
                    if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                        value = jQuery(option).val();
                        if (one) {
                            return value;
                        }
                        values.push(value);
                    }
                }
                return values;
            },
            set: function(elem, value) {
                var optionSet, option, options = elem.options,
                    values = jQuery.makeArray(value),
                    i = options.length;
                while (i--) {
                    option = options[i];
                    if ((option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0)) {
                        optionSet = true;
                    }
                }
                if (!optionSet) {
                    elem.selectedIndex = -1;
                }
                return values;
            }
        }
    }
});
$.fn.extend({
    find: function(a) {
        var b, c = [],
            d = this,
            e = d.length;
        if (typeof a != "string") return this.pushStack($(a).filter(function() {
            for (b = 0; b < e; b++)
                if ($.contains(d[b], this)) return !0
        }));
        for (b = 0; b < e; b++) $.find(a, d[b], c);
        c = this.pushStack(e > 1 ? $.unique(c) : c);
        c.selector = this.selector ? this.selector + " " + a : a;
        return c
    },
    filter: function(a) {
        return this.pushStack(winnow(this, a || [], !1))
    },
    not: function(a) {
        return this.pushStack(winnow(this, a || [], !0))
    },
    is: function(a) {
        return !!winnow(this, typeof a == "string" && rneedsContext.test(a) ? $(a) : a || [], !1).length
    }
});
var getText = $.getText = function(a) {
    var b, c, d = a.nodeType,
        e = "";
    if (d) {
        if (d === 1 || d === 9 || d === 11) {
            if (typeof a.textContent == "string") return a.textContent;
            if (typeof a.innerText == "string") return a.innerText.replace(k, "");
            for (a = a.firstChild; a; a = a.nextSibling) e += getText(a);
        } else if (d === 3 || d === 4) return a.nodeValue;
    } else
        for (b = 0; c = a[b]; b++) c.nodeType !== 8 && (e += getText(c));
    return e;
};

var selectors = $.selectors = {
    order: ["ID", "NAME", "TAG"],
    match: {
        ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
        CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
        NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
        ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
        TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
        CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
        POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
        PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
    },
    leftMatch: {},
    attrMap: {
        "class": "className",
        "for": "htmlFor"
    },
    attrHandle: {
        href: function(a) {
            return a.getAttribute("href");
        },
        type: function(a) {
            return a.getAttribute("type");
        }
    },
    relative: {
        "+": function(a, b) {
            var c = typeof b == "string",
                d = c && !l.test(b),
                e = c && !d;
            d && (b = b.toLowerCase());
            for (var f = 0, g = a.length, h; f < g; f++)
                if (h = a[f]) {
                    while ((h = h.previousSibling) && h.nodeType !== 1);
                    a[f] = e || h && h.nodeName.toLowerCase() === b ? h || !1 : h === b;
                }
            e && $.filter(b, a, !0);
        },
        ">": function(a, b) {
            var c, d = typeof b == "string",
                e = 0,
                f = a.length;
            if (d && !l.test(b)) {
                b = b.toLowerCase();
                for (; e < f; e++) {
                    c = a[e];
                    if (c) {
                        var g = c.parentNode;
                        a[e] = g.nodeName.toLowerCase() === b ? g : !1;
                    }
                }
            } else {
                for (; e < f; e++) c = a[e], c && (a[e] = d ? c.parentNode : c.parentNode === b);
                d && $.filter(b, a, !0);
            }
        }
    }
};
var filters = $.filters = {
    enabled: function(a) {
        return a.disabled === false && a.type !== "hidden";
    },
    disabled: function(a) {
        return a.disabled === true;
    },
    checked: function(a) {
        return a.checked === true;
    },
    selected: function(a) {
        return a.parentNode && a.parentNode.selectedIndex;
    },
    parent: function(a) {
        return !!a.firstChild;
    },
    empty: function(a) {
        return !a.firstChild;
    },
    has: function(a, b, c) {
        return !!$.find(c[3], a).length;
    },
    header: function(a) {
        return /h\d/i.test(a.nodeName);
    },
    text: function(a) {
        var b = a.getAttribute("type"),
            c = a.type;
        return a.nodeName.toLowerCase() === "input" && c === "text" && (b === c || b === null);
    },
    radio: function(a) {
        return a.nodeName.toLowerCase() === "input" && a.type === "radio";
    },
    checkbox: function(a) {
        return a.nodeName.toLowerCase() === "input" && a.type === "checkbox";
    },
    file: function(a) {
        return a.nodeName.toLowerCase() === "input" && a.type === "file";
    },
    password: function(a) {
        return a.nodeName.toLowerCase() === "input" && a.type === "password";
    },
    submit: function(a) {
        var b = a.nodeName.toLowerCase();
        return (b === "input" || b === "button") && a.type === "submit";
    },
    image: function(a) {
        return a.nodeName.toLowerCase() === "input" && a.type === "image";
    },
    reset: function(a) {
        var b = a.nodeName.toLowerCase();
        return (b === "input" || b === "button") && a.type === "reset";
    },
    button: function(a) {
        var b = a.nodeName.toLowerCase();
        return b === "input" && a.type === "button" || b === "button";
    },
    input: function(a) {
        return /input|select|textarea|button/i.test(a.nodeName);
    },
    focus: function(a) {
        return a === a.ownerDocument.activeElement;
    }
};

var setFilters = $.setFilters = {
    first: function(a, b) {
        return b === 0;
    },
    last: function(a, b, c, d) {
        return b === d.length - 1;
    },
    even: function(a, b) {
        return b % 2 === 0;
    },
    odd: function(a, b) {
        return b % 2 === 1;
    },
    lt: function(a, b, c) {
        return b < c[3] - 0;
    },
    gt: function(a, b, c) {
        return b > c[3] - 0;
    },
    nth: function(a, b, c) {
        return c[3] - 0 === b;
    },
    eq: function(a, b, c) {
        return c[3] - 0 === b;
    }
};
var filter = $.filter = {
    PSEUDO: function(a, b, c, d) {
        var e = b[1],
            f = filters[e];
        if (f) return f(a, c, b, d);
        if (e === "contains") return (a.textContent || a.innerText || getText([a]) || "").indexOf(b[3]) >= 0;
        if (e === "not") {
            var g = b[3];
            for (var h = 0, i = g.length; h < i; h++)
                if (g[h] === a) return false;
            return true;
        }
        $.error(e);
    },
    CHILD: function(a, b) {
        var c, e, f, g, h, i, j, k = b[1],
            l = a;
        switch (k) {
            case "only":
            case "first":
                while (l = l.previousSibling)
                    if (l.nodeType === 1) return false;
                if (k === "first") return true;
                l = a;
            case "last":
                while (l = l.nextSibling)
                    if (l.nodeType === 1) return false;
                return true;
            case "nth":
                c = b[2], e = b[3];
                if (c === 1 && e === 0) return true;
                f = b[0], g = a.parentNode;
                if (g && (g.nodeIndex !== f || !a.nodeIndex)) {
                    i = 0;
                    for (l = g.firstChild; l; l = l.nextSibling)
                        if (l.nodeType === 1) l.nodeIndex = ++i;
                    g.nodeIndex = f;
                }
                j = a.nodeIndex - e;
                return c === 0 ? j === 0 : j % c === 0 && j / c >= 0;
        }
    },
    ID: function(a, b) {
        return a.nodeType === 1 && a.getAttribute("id") === b;
    },
    TAG: function(a, b) {
        return b === "*" && a.nodeType === 1 || !!a.nodeName && a.nodeName.toLowerCase() === b;
    },
    CLASS: function(a, b) {
        return (" " + (a.className || a.getAttribute("class")) + " ").indexOf(b) > -1;
    },
    ATTR: function(a, b) {
        var c = b[1],
            d = $.attr ? $.attr(a, c) : attrHandle[c] ? attrHandle[c](a) : a[c] != null ? a[c] : a.getAttribute(c),
            e = d + "",
            f = b[2],
            g = b[4];
        return d == null ? f === "!=" : !f && $.attr ? d != null : f === "=" ? e === g : f === "*=" ? e.indexOf(g) >= 0 : f === "~=" ? (" " + e + " ").indexOf(g) >= 0 : g ? f === "!=" ? e !== g : f === "^=" ? e.indexOf(g) === 0 : f === "$=" ? e.substr(e.length - g.length) === g : f === "|=" ? e === g || e.substr(0, g.length + 1) === g + "-" : false : e && d !== false;
    },
    POS: function(a, b, c, d) {
        var e = b[2],
            f = setFilters[e];
        if (f) return f(a, c, b, d);
    }
};
var p = match.POS,
    q = function(a, b) {
        return "\\" + (b - 0 + 1);
    };

for (var r in match) match[r] = new RegExp(match[r].source + /(?![^\[]*\])(?![^\(]*\))/.source), leftMatch[r] = new RegExp(/(^(?:.|\r|\n)*?)/.source + match[r].source.replace(/\\(\d+)/g, q));

match.globalPOS = p;

var s = function(a, b) {
    a = Array.prototype.slice.call(a, 0);
    if (b) {
        b.push.apply(b, a);
        return b;
    }
    return a;
};

try {
    Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;
} catch (t) {
    s = function(a, b) {
        var c = 0,
            d = b || [];
        if (Object.prototype.toString.call(a) === "[object Array]") Array.prototype.push.apply(d, a);
        else if (typeof a.length == "number")
            for (var e = a.length; c < e; c++) d.push(a[c]);
        else
            for (; a[c]; c++) d.push(a[c]);
        return d;
    };
}

var u, v;

document.documentElement.compareDocumentPosition ? u = function(a, b) {
        if (a === b) {
            h = !0;
            return 0;
        }
        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return a.compareDocumentPosition ? -1 : 1;
        return a.compareDocumentPosition(b) & 4 ? -1 : 1;
    } :
    (u = function(a, b) {
        if (a === b) {
            h = !0;
            return 0;
        }
        if (a.sourceIndex && b.sourceIndex) return a.sourceIndex - b.sourceIndex;
        var c, d, e = [],
            f = [],
            g = a.parentNode,
            i = b.parentNode,
            j = g;
        if (g === i) return v(a, b);
        if (!g) return -1;
        if (!i) return 1;
        while (j) e.unshift(j), j = j.parentNode;
        j = i;
        while (j) f.unshift(j), j = j.parentNode;
        c = e.length, d = f.length;
        for (var k = 0; k < c && k < d; k++)
            if (e[k] !== f[k]) return v(e[k], f[k]);
        return k === c ? v(a, f[k], -1) : v(e[k], b, 1);
    }, v = function(a, b, c) {
        if (a === b) return c;
        var d = a.nextSibling;
        while (d) {
            if (d === b) return -1;
            d = d.nextSibling;
        }
        return 1;
    });

(function() {
    var a = document.createElement("div"),
        d = "script" + (new Date).getTime(),
        e = document.documentElement;
    a.innerHTML = "<a name='" + d + "'/>";
    e.insertBefore(a, e.firstChild);
    if (document.getElementById(d)) {
        find.ID = function(a, c, d) {
            if (typeof c.getElementById != "undefined" && !d) {
                var e = c.getElementById(a[1]);
                return e ? e.id === a[1] || typeof e.getAttributeNode != "undefined" && e.getAttributeNode("id").nodeValue === a[1] ? [e] : [] : [];
            }
        };
        filter.ID = function(a, b) {
            var c = typeof a.getAttributeNode != "undefined" && a.getAttributeNode("id");
            return a.nodeType === 1 && c && c.nodeValue === b;
        };
    }
    e.removeChild(a);
    e = a = null;
})();
(function() {
    var a = document.createElement("div");
    a.appendChild(document.createComment(""));
    if (a.getElementsByTagName("*").length > 0) {
        find.TAG = function(a, b) {
            var c = b.getElementsByTagName(a[1]);
            if (a[1] === "*") {
                var d = [];
                for (var e = 0; c[e]; e++) {
                    if (c[e].nodeType === 1) {
                        d.push(c[e]);
                    }
                }
                c = d;
            }
            return c;
        };
    }
    a.innerHTML = "<a href='#'></a>";
    if (a.firstChild && typeof a.firstChild.getAttribute != "undefined" && a.firstChild.getAttribute("href") !== "#") {
        attrHandle.href = function(a) {
            return a.getAttribute("href", 2);
        };
    }
    a = null;
})();

if (document.querySelectorAll) {
    (function() {
        var a = jQuery,
            b = document.createElement("div"),
            d = "__sizzle__";
        b.innerHTML = "<p class='TEST'></p>";
        if (!b.querySelectorAll || b.querySelectorAll(".TEST").length !== 0) {
            jQuery = function(b, e, f, g) {
                e = e || document;
                if (!g && !jQuery.isXML(e)) {
                    var h = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec(b);
                    if (h && (e.nodeType === 1 || e.nodeType === 9)) {
                        if (h[1]) return s(e.getElementsByTagName(b), f);
                        if (h[2] && find.CLASS && e.getElementsByClassName) return s(e.getElementsByClassName(h[2]), f);
                    }
                    if (e.nodeType === 9) {
                        if (b === "body" && e.body) return s([e.body], f);
                        if (h && h[3]) {
                            var i = e.getElementById(h[3]);
                            if (!i || !i.parentNode) return s([], f);
                            if (i.id === h[3]) return s([i], f);
                        }
                        try {
                            return s(e.querySelectorAll(b), f);
                        } catch (j) {}
                    } else if (e.nodeType === 1 && e.nodeName.toLowerCase() !== "object") {
                        var k = e,
                            l = e.getAttribute("id"),
                            n = l || d,
                            p = e.parentNode,
                            q = /^\s*[+~]/.test(b);
                        l ? n = n.replace(/'/g, "\\$&") : e.setAttribute("id", n);
                        if (q && p) e = e.parentNode;
                        try {
                            if (!q || p) return s(e.querySelectorAll("[id='" + n + "'] " + b), f);
                        } catch (r) {} finally {
                            l || k.removeAttribute("id");
                        }
                    }
                }
                return a(b, e, f, g);
            };
            for (var e in a) {
                jQuery[e] = a[e];
            }
            b = null;
        }
    })();
}

(function() {
    var a = document.documentElement,
        b = a.matches || a.webkitMatchesSelector || a.mozMatchesSelector || a.msMatchesSelector;
    if (b) {
        var d = !b.call(document.createElement("div"), "div"),
            e = !1;
        try {
            b.call(document.documentElement, "[test!='']:sizzle");
        } catch (f) {
            e = !0;
        }
        jQuery.matchesSelector = function(a, c) {
            c = c.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");
            if (!jQuery.isXML(a)) {
                try {
                    if (e || !match.PSEUDO.test(c) && !/!=/.test(c)) {
                        var g = b.call(a, c);
                        if (g || !d || a.document && a.document.nodeType !== 11) return g;
                    }
                } catch (h) {}
                return jQuery(c, null, null, [a]).length > 0;
            }
        };
    }
})();
(function() {
    var a = document.createElement("div");
    a.innerHTML = "<div class='test e'></div><div class='test'></div>";
    if (!!a.getElementsByClassName && a.getElementsByClassName("e").length !== 0) {
        a.lastChild.className = "e";
        if (a.getElementsByClassName("e").length === 1) return;
        order.splice(1, 0, "CLASS");
        find.CLASS = function(a, b, c) {
            if (typeof b.getElementsByClassName != "undefined" && !c) return b.getElementsByClassName(a[1]);
        };
        a = null;
    }
})();

if (document.documentElement.contains) {
    contains = function(a, b) {
        return a !== b && (a.contains ? a.contains(b) : !0);
    };
} else if (document.documentElement.compareDocumentPosition) {
    contains = function(a, b) {
        return !!(a.compareDocumentPosition(b) & 16);
    };
} else {
    contains = function() {
        return !1;
    };
}

isXML = function(a) {
    var b = (a ? a.ownerDocument || a : 0).documentElement;
    return b ? b.nodeName !== "HTML" : !1;
};

var y = function(a, b, c) {
    var d, e = [],
        f = "",
        g = b.nodeType ? [b] : b;
    while (d = o.match.PSEUDO.exec(a)) {
        f += d[0];
        a = a.replace(o.match.PSEUDO, "");
    }
    a = o.relative[a] ? a + "*" : a;
    for (var h = 0, i = g.length; h < i; h++) {
        m(a, g[h], e, c);
    }
    return m.filter(f, e);
};

attr = f.attr;
selectors.attrMap = {};
find = m;
expr = selectors;
expr[":"] = expr.filters;
unique = m.uniqueSort;
text = m.getText;
isXMLDoc = m.isXML;
contains = m.contains;

var L = /Until$/,
    M = /^(?:parents|prevUntil|prevAll)/,
    N = /,/,
    O = /^.[^:#\[\.,]*$/,
    P = Array.prototype.slice,
    Q = expr.match.globalPOS,
    R = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };

f.fn.extend({
    find: function(a) {
        var b = this,
            c, d;
        if (typeof a != "string") return f(a).filter(function() {
            for (c = 0, d = b.length; c < d; c++)
                if (f.contains(b[c], this)) return !0;
        });
        var e = this.pushStack("", "find", a),
            g, h, i;
        for (c = 0, d = this.length; c < d; c++) {
            g = e.length, f.find(a, this[c], e);
            if (c > 0)
                for (h = g; h < e.length; h++)
                    for (i = 0; i < g; i++)
                        if (e[i] === e[h]) {
                            e.splice(h--, 1);
                            break;
                        }
        }
        return e;
    },
    has: function(a) {
        var b = f(a);
        return this.filter(function() {
            for (var a = 0, c = b.length; a < c; a++)
                if (f.contains(this, b[a])) return !0;
        });
    },
    not: function(a) {
        return this.pushStack(T(this, a, !1), "not", a);
    },
    filter: function(a) {
        return this.pushStack(T(this, a, !0), "filter", a);
    },
    is: function(a) {
        return !!a && (typeof a == "string" ? Q.test(a) ? f(a, this.context).index(this[0]) >= 0 : f.filter(a, this).length > 0 : this.filter(a).length > 0);
    },
    closest: function(a, b) {
        var c = [],
            d, e, g = this[0];
        if (f.isArray(a)) {
            var h = 1;
            while (g && g.ownerDocument && g !== b) {
                for (d = 0; d < a.length; d++) f(g).is(a[d]) && c.push({
                    selector: a[d],
                    elem: g,
                    level: h
                });
                g = g.parentNode, h++;
            }
            return c;
        }
    }
});
var i = Q.test(a) || typeof a != "string" ? f(a, b || this.context) : 0;
for (d = 0, e = this.length; d < e; d++) {
    g = this[d];
    while (g) {
        if (i ? i.index(g) > -1 : f.find.matchesSelector(g, a)) {
            c.push(g);
            break;
        }
        g = g.parentNode;
        if (!g || !g.ownerDocument || g === b || g.nodeType === 11) break;
    }
}
c = c.length > 1 ? f.unique(c) : c;
return this.pushStack(c, "closest", a);

index: function(a) {
    if (!a) return this[0] && this[0].parentNode ? this.prevAll().length : -1;
    if (typeof a == "string") return f.inArray(this[0], f(a));
    return f.inArray(a.jquery ? a[0] : a, this);
},
add: function(a, b) {
    var c = typeof a == "string" ? f(a, b) : f.makeArray(a && a.nodeType ? [a] : a),
        d = f.merge(this.get(), c);
    return this.pushStack(S(c[0]) || S(d[0]) ? d : f.unique(d));
},
andSelf: function() {
    return this.add(this.prevObject);
}

f.each({
    parent: function(a) {
        var b = a.parentNode;
        return b && b.nodeType !== 11 ? b : null;
    },
    parents: function(a) {
        return f.dir(a, "parentNode");
    },
    parentsUntil: function(a, b, c) {
        return f.dir(a, "parentNode", c);
    },
    next: function(a) {
        return f.nth(a, 2, "nextSibling");
    },
    prev: function(a) {
        return f.nth(a, 2, "previousSibling");
    },
    nextAll: function(a) {
        return f.dir(a, "nextSibling");
    },
    prevAll: function(a) {
        return f.dir(a, "previousSibling");
    },
    nextUntil: function(a, b, c) {
        return f.dir(a, "nextSibling", c);
    },
    prevUntil: function(a, b, c) {
        return f.dir(a, "previousSibling", c);
    },
    siblings: function(a) {
        return f.sibling((a.parentNode || {}).firstChild, a);
    },
    children: function(a) {
        return f.sibling(a.firstChild);
    },
    contents: function(a) {
        return f.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : f.makeArray(a.childNodes);
    }
}, function(a, b) {
    f.fn[a] = function(c, d) {
        var e = f.map(this, b, c);
        L.test(a) || (d = c), d && typeof d == "string" && (e = f.filter(d, e)), e = this.length > 1 && !R[a] ? f.unique(e) : e, (this.length > 1 || N.test(d)) && M.test(a) && (e = e.reverse());
        return this.pushStack(e, a, P.call(arguments).join(","));
    };
}),
f.extend({
    filter: function(a, b, c) {
        c && (a = ":not(" + a + ")");
        return b.length === 1 ? f.find.matchesSelector(b[0], a) ? [b[0]] : [] : f.find.matches(a, b);
    },
    dir: function(a, c, d) {
        var e = [],
            g = a[c];
        while (g && g.nodeType !== 9 && (d === b || g.nodeType !== 1 || !f(g).is(d))) g.nodeType === 1 && e.push(g), g = g[c];
        return e;
    },
    nth: function(a, b, c, d) {
        b = b || 1;
        var e = 0;
        for (; a; a = a[c])
            if (a.nodeType === 1 && ++e === b) break;
        return a;
    },
    sibling: function(a, b) {
        var c = [];
        for (; a; a = a.nextSibling) a.nodeType === 1 && a !== b && c.push(a);
        return c;
    }
});

var V = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
    W = / jQuery\d+="(?:\d+|null)"/g,
    X = /^\s+/,
    Y = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
    Z = /<([\w:]+)/,
    $ = /<tbody/i,
    _ = /<|&#?\w+;/,
    ba = /<(?:script|style)/i,
    bb = /<(?:script|object|embed|option|style)/i,
    bc = new RegExp("<(?:" + V + ")[\\s/>]", "i"),
    bd = /checked\s*(?:[^=]|=\s*.checked.)/i,
    be = /\/(java|ecma)script/i,
    bf = /^\s*<!(?:\[CDATA\[|\-\-)/,
    bg = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        legend: [1, "<fieldset>", "</fieldset>"],
        thead: [1, "<table>", "</table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
        area: [1, "<map>", "</map>"],
        _default: [0, "", ""]
    },
    bh = U(c);
    bg.optgroup = bg.option;
    bg.tbody = bg.tfoot = bg.colgroup = bg.caption = bg.thead;
    bg.th = bg.td;
    
    if (!f.support.htmlSerialize) {
        bg._default = [1, "div<div>", "</div>"];
    }
    
    f.fn.extend({
        text: function(a) {
            return f.access(this, function(a) {
                return a === undefined ? f.text(this) : this.empty().append((this[0] && this[0].ownerDocument || c).createTextNode(a));
            }, null, a, arguments.length);
        },
        wrapAll: function(a) {
            if (f.isFunction(a)) {
                return this.each(function(b) {
                    f(this).wrapAll(a.call(this, b));
                });
            }
            if (this[0]) {
                var b = f(a, this[0].ownerDocument).eq(0).clone(true);
                this[0].parentNode && b.insertBefore(this[0]);
                b.map(function() {
                    var a = this;
                    while (a.firstChild && a.firstChild.nodeType === 1) {
                        a = a.firstChild;
                    }
                    return a;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(a) {
            if (f.isFunction(a)) {
                return this.each(function(b) {
                    f(this).wrapInner(a.call(this, b));
                });
            }
            return this.each(function() {
                var b = f(this),
                    c = b.contents();
                if (c.length) {
                    c.wrapAll(a);
                } else {
                    b.append(a);
                }
            });
        },
        wrap: function(a) {
            var b = f.isFunction(a);
            return this.each(function(c) {
                f(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                if (!f.nodeName(this, "body")) {
                    f(this).replaceWith(this.childNodes);
                }
            }).end();
        },
        append: function() {
            return this.domManip(arguments, true, function(a) {
                if (this.nodeType === 1) {
                    this.appendChild(a);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, true, function(a) {
                if (this.nodeType === 1) {
                    this.insertBefore(a, this.firstChild);
                }
            });
        },
        before: function() {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function(a) {
                    this.parentNode.insertBefore(a, this);
                });
            }
            if (arguments.length) {
                var a = f.clean(arguments);
                a.push.apply(a, this.toArray());
                return this.pushStack(a, "before", arguments);
            }
        },
        after: function() {
            if (this[0] && this[0].parentNode) {
                return this.domManip(arguments, false, function(a) {
                    this.parentNode.insertBefore(a, this.nextSibling);
                });
            }
            if (arguments.length) {
                var a = this.pushStack(this, "after", arguments);
                a.push.apply(a, f.clean(arguments));
                return a;
            }
        },
        remove: function(a, b) {
            for (var c = 0, d; (d = this[c]) != null; c++) {
                if (!a || f.filter(a, [d]).length) {
                    if (!b && d.nodeType === 1) {
                        f.cleanData(d.getElementsByTagName("*"));
                        f.cleanData([d]);
                    }
                    if (d.parentNode) {
                        d.parentNode.removeChild(d);
                    }
                }
            }
            return this;
        },
        empty: function() {
            for (var a = 0, b; (b = this[a]) != null; a++) {
                if (b.nodeType === 1) {
                    f.cleanData(b.getElementsByTagName("*"));
                    while (b.firstChild) {
                        b.removeChild(b.firstChild);
                    }
                }
            }
            return this;
        }
    });
    clone: function(a, b) {
        a = a == null ? false : a;
        b = b == null ? a : b;
        return this.map(function() {
            return f.clone(this, a, b);
        });
    },
    html: function(a) {
        return f.access(this, function(a) {
            var c = this[0] || {},
                d = 0,
                e = this.length;
            if (a === undefined) {
                return c.nodeType === 1 ? c.innerHTML.replace(W, "") : null;
            }
            if (typeof a == "string" && !ba.test(a) && (f.support.leadingWhitespace || !X.test(a)) && !bg[(Z.exec(a) || ["", ""])[1].toLowerCase()]) {
                a = a.replace(Y, "<$1></$2>");
                try {
                    for (; d < e; d++) {
                        c = this[d] || {};
                        if (c.nodeType === 1) {
                            f.cleanData(c.getElementsByTagName("*"));
                            c.innerHTML = a;
                        }
                    }
                    c = 0;
                } catch (g) {}
            }
            c && this.empty().append(a);
        }, null, a, arguments.length);
    },
    replaceWith: function(a) {
        if (this[0] && this[0].parentNode) {
            if (f.isFunction(a)) {
                return this.each(function(b) {
                    var c = f(this),
                        d = c.html();
                    c.replaceWith(a.call(this, b, d));
                });
            }
            typeof a != "string" && (a = f(a).detach());
            return this.each(function() {
                var b = this.nextSibling,
                    c = this.parentNode;
                f(this).remove();
                b ? f(b).before(a) : f(c).append(a);
            });
        }
        return this.length ? this.pushStack(f(f.isFunction(a) ? a() : a), "replaceWith", a) : this;
    },
    detach: function(a) {
        return this.remove(a, true);
    },
    domManip: function(a, c, d) {
        var e, g, h, i, j = a[0],
            k = [];
        if (!f.support.checkClone && arguments.length === 3 && typeof j == "string" && bd.test(j)) {
            return this.each(function() {
                f(this).domManip(a, c, d, true);
            });
        }
        if (f.isFunction(j)) {
            return this.each(function(e) {
                var g = f(this);
                a[0] = j.call(this, e, c ? g.html() : undefined);
                g.domManip(a, c, d);
            });
        }
        if (this[0]) {
            i = j && j.parentNode;
            if (f.support.parentNode && i && i.nodeType === 11 && i.childNodes.length === this.length) {
                e = {
                    fragment: i
                };
            } else {
                e = f.buildFragment(a, this, k);
            }
            h = e.fragment;
            h.childNodes.length === 1 ? g = h = h.firstChild : g = h.firstChild;
            if (g) {
                c = c && f.nodeName(g, "tr");
                for (var l = 0, m = this.length, n = m - 1; l < m; l++) {
                    d.call(c ? bi(this[l], g) : this[l], e.cacheable || m > 1 && l < n ? f.clone(h, true, true) : h);
                }
            }
            k.length && f.each(k, function(a, b) {
                if (b.src) {
                    f.ajax({
                        type: "GET",
                        global: false,
                        url: b.src,
                        async: false,
                        dataType: "script"
                    });
                } else {
                    f.globalEval((b.text || b.textContent || b.innerHTML || "").replace(bf, "/*$0*/"));
                }
                b.parentNode && b.parentNode.removeChild(b);
            });
        }
        return this;
    }
}), f.buildFragment = function(a, b, d) {
    var e, g, h, i, j = a[0];
    b && b[0] && (i = b[0].ownerDocument || b[0]), i.createDocumentFragment || (i = c), a.length === 1 && typeof j == "string" && j.length < 512 && i === c && j.charAt(0) === "<" && !bb.test(j) && (f.support.checkClone || !bd.test(j)) && (f.support.html5Clone || !bc.test(j)) && (g = true, h = f.fragments[j], h && h !== 1 && (e = h)), e || (e = i.createDocumentFragment(), f.clean(a, i, e, d)), g && (f.fragments[j] = h ? e : 1);
    return {
        fragment: e,
        cacheable: g
    }
}, f.fragments = {}, f.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
}, function(a, b) {
    f.fn[a] = function(c) {
        var d = [],
            e = f(c),
            g = this.length === 1 && this[0].parentNode;
        if (g && g.nodeType === 11 && g.childNodes.length === 1 && e.length === 1) {
            e[b](this[0]);
            return this
        }
        for (var h = 0, i = e.length; h < i; h++) {
            var j = (h > 0 ? this.clone(true) : this).get();
            f(e[h])[b](j), d = d.concat(j)
        }
        return this.pushStack(d, a, e.selector)
    }
}), f.extend({
    clone: function(a, b, c) {
        var d, e, g, h = f.support.html5Clone || f.isXMLDoc(a) || !bc.test("<" + a.nodeName + ">") ? a.cloneNode(true) : bo(a);
        if ((!f.support.noCloneEvent || !f.support.noCloneChecked) && (a.nodeType === 1 || a.nodeType === 11) && !f.isXMLDoc(a)) {
            bk(a, h), d = bl(a), e = bl(h);
            for (g = 0; d[g]; ++g) e[g] && bk(d[g], e[g])
        }
        if (b) {
            bj(a, h);
            if (c) {
                d = bl(a), e = bl(h);
                for (g = 0; d[g]; ++g) bj(d[g], e[g])
            }
        }
        d = e = null;
        return h
    },
    clean: function(a, b, d, e) {
        var g, h, i, j = [];
        b = b || c, typeof b.createElement == "undefined" && (b = b.ownerDocument || b[0] && b[0].ownerDocument || c);
        for (var k = 0, l; (l = a[k]) != null; k++) {
            typeof l == "number" && (l += "");
            if (!l) continue;
            if (typeof l == "string")
                if (!_.test(l)) l = b.createTextNode(l);
                else {
                    l = l.replace(Y, "<$1></$2>");
                    var m = (Z.exec(l) || ["", ""])[1].toLowerCase(),
                        n = bg[m] || bg._default,
                        o = n[0],
                        p = b.createElement("div"),
                        q = bh.childNodes,
                        r;
                    b === c ? bh.appendChild(p) : U(b).appendChild(p), p.innerHTML = n[1] + l + n[2];
                    while (o--) p = p.lastChild;
                    if (!f.support.tbody) {
                        var s = $.test(l),
                            t = m === "table" && !s ? p.firstChild && p.firstChild.childNodes : n[1] === "<table>" && !s ? p.childNodes : [];
                        for (i = t.length - 1; i >= 0; --i) f.nodeName(t[i], "tbody") && !t[i].childNodes.length && t[i].parentNode.removeChild(t[i])
                    }!f.support.leadingWhitespace && X.test(l) && p.insertBefore(b.createTextNode(X.exec(l)[0]), p.firstChild), l = p.childNodes, p && (p.parentNode.removeChild(p), q.length > 0 && (r = q[q.length - 1], r && r.parentNode && r.parentNode.removeChild(r)))
                } var u;
            if (!f.support.appendChecked)
                if (l[0] && typeof(u = l.length) == "number")
                    for (i = 0; i < u; i++) bn(l[i]);
                else bn(l);
            l.nodeType ? j.push(l) : j = f.merge(j, l)
        }
        if (d) {
            g = function(a) {
                return !a.type || be.test(a.type)
            };
            for (k = 0; j[k]; k++) {
                h = j[k];
                if (e && f.nodeName(h, "script") && (!h.type || be.test(h.type))) e.push(h.parentNode ? h.parentNode.removeChild(h) : h);
                else {
                    if (h.nodeType === 1) {
                        var v = f.grep(h.getElementsByTagName("script"), g);
                        j.splice.apply(j, [k + 1, 0].concat(v))
                    }
                    d.appendChild(h)
                }
            }
        }
        return j
    },
    cleanData: function(a) {
        var b, c, d = f.cache,
            e = f.event.special,
            g = f.support.deleteExpando;
        for (var h = 0, i; (i = a[h]) != null; h++) {
            if (i.nodeName && f.noData[i.nodeName.toLowerCase()]) continue;
            c = i[f.expando];
            if (c) {
                b = d[c];
                if (b && b.events) {
                    for (var j in b.events) e[j] ? f.event.remove(i, j) : f.removeEvent(i, j, b.handle);
                    b.handle && (b.handle.elem = null)
                }
                g ? delete i[f.expando] : i.removeAttribute && i.removeAttribute(f.expando), delete d[c]
            }
        }
    }
});
var bp = /alpha\([^)]*\)/i,
    bq = /opacity=([^)]*)/,
    br = /([A-Z]|^ms)/g,
    bs = /^[\-+]?(?:\d*\.)?\d+$/i,
    bt = /^-?(?:\d*\.)?\d+(?!px)[^\d\s]+$/i,
    bu = /^([\-+])=([\-+.\de]+)/,
    bv = /^margin/,
    bw = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    },
    bx = ["Top", "Right", "Bottom", "Left"],
    by, bz, bA;
f.fn.css = function(a, c) {
    return f.access(this, function(a, c, d) {
        return d !== undefined ? f.style(a, c, d) : f.css(a, c)
    }, a, c, arguments.length > 1)
}, f.extend({
    cssHooks: {
        opacity: {
            get: function(a, b) {
                if (b) {
                    var c = by(a, "opacity");
                    return c === "" ? "1" : c
                }
                return a.style.opacity
            }
        }
    },
    cssNumber: {
        fillOpacity: true,
        fontWeight: true,
        lineHeight: true,
        opacity: true,
        orphans: true,
        widows: true,
        zIndex: true,
        zoom: true
    },
    cssProps: {
        "float": f.support.cssFloat ? "cssFloat" : "styleFloat"
    },
    style: function(a, c, d, e) {
        if (!!a && a.nodeType !== 3 && a.nodeType !== 8 && !!a.style) {
            var g, h, i = f.camelCase(c),
                j = a.style,
                k = f.cssHooks[i];
            c = f.cssProps[i] || i;
            if (d === undefined) {
                if (k && "get" in k && (g = k.get(a, false, e)) !== undefined) return g;
                return j[c]
            }
            h = typeof d, h === "string" && (g = bu.exec(d)) && (d = +(g[1] + 1) * +g[2] + parseFloat(f.css(a, c)), h = "number");
            if (d == null || h === "number" && isNaN(d)) return;
            h === "number" && !f.cssNumber[i] && (d += "px");
            if (!k || !("set" in k) || (d = k.set(a, d)) !== undefined) try {
                j[c] = d
            } catch (l) {}
        }
    },
    css: function(a, c, d) {
        var e, g;
        c = f.camelCase(c), g = f.cssHooks[c], c = f.cssProps[c] || c, c === "cssFloat" && (c = "float");
        if (g && "get" in g && (e = g.get(a, true, d)) !== undefined) return e;
        if (by) return by(a, c)
    },
    swap: function(a, b, c) {
        var d = {},
            e, f;
        for (f in b) d[f] = a.style[f], a.style[f] = b[f];
        e = c.call(a);
        for (f in b) a.style[f] = d[f];
        return e
    }
}), f.curCSS = f.css, c.defaultView && c.defaultView.getComputedStyle && (bz = function(a, b) {
    var c, d, e, g, h = a.style;
    b = b.replace(br, "-$1").toLowerCase(), (d = a.ownerDocument.defaultView) && (e = d.getComputedStyle(a, null)) && (c = e.getPropertyValue(b), c === "" && !f.contains(a.ownerDocument.documentElement, a) && (c = f.style(a, b))), !f.support.pixelMargin && e && bv.test(b) && bt.test(c) && (g = h.width, h.width = c, c = e.width, h.width = g);
    return c
}), c.documentElement.currentStyle && (bA = function(a, b) {
    var c, d, e, f = a.currentStyle && a.currentStyle[b],
        g = a.style;
    f == null && g && (e = g[b]) && (f = e), bt.test(f) && (c = g.left, d = a.runtimeStyle && a.runtimeStyle.left, d && (a.runtimeStyle.left = a.currentStyle.left), g.left = b === "fontSize" ? "1em" : f, f = g.pixelLeft + "px", g.left = c, d && (a.runtimeStyle.left = d));
    return f === "" ? "auto" : f
}), by = bz || bA, f.each(["height", "width"], function(a, b) {
    f.cssHooks[b] = {
        get: function(a, c, d) {
            if (c) return a.offsetWidth !== 0 ? bB(a, b, d) : f.swap(a, bw, function() {
                return bB(a, b, d)
            })
        },
        set: function(a, b) {
            return bs.test(b) ? b + "px" : b
        }
    }
}), f.support.opacity || (f.cssHooks.opacity = {
    get: function(a, b) {
        return bq.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? parseFloat(RegExp.$1) / 100 + "" : b ? "1" : ""
    },
    set: function(a, b) {
        var c = a.style,
            d = a.currentStyle,
            e = f.isNumeric(b) ? "alpha(opacity=" + b * 100 + ")" : "",
            g = d && d.filter || c.filter || "";
        c.zoom = 1;
        if (b >= 1 && f.trim(g.replace(bp, "")) === "") {
            c.removeAttribute("filter");
            if (d && !d.filter) return
        }
        c.filter = bp.test(g) ? g.replace(bp, e) : g + " " + e
    }
}), f(function() {
    f.support.reliableMarginRight || (f.cssHooks.marginRight = {
        get: function(a, b) {
            return f.swap(a, {
                display: "inline-block"
            }, function() {
                return b ? by(a, "margin-right") : a.style.marginRight
            })
        }
    })
})
if (f.expr && f.expr.filters) {
    f.expr.filters.hidden = function(a) {
        var b = a.offsetWidth,
            c = a.offsetHeight;
        return b === 0 && c === 0 || !f.support.reliableHiddenOffsets && (a.style && a.style.display || f.css(a, "display")) === "none";
    };
    f.expr.filters.visible = function(a) {
        return !f.expr.filters.hidden(a);
    };
}
f.each({
    margin: "",
    padding: "",
    border: "Width"
}, function(a, b) {
    f.cssHooks[a + b] = {
        expand: function(c) {
            var d, e = typeof c === "string" ? c.split(" ") : [c],
                f = {};
            for (d = 0; d < 4; d++) f[a + bx[d] + b] = e[d] || e[d - 2] || e[0];
            return f;
        }
    };
});
var bC = /%20/g,
    bD = /\[\]$/,
    bE = /\r?\n/g,
    bF = /#.*$/,
    bG = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
    bH = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
    bI = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
    bJ = /^(?:GET|HEAD)$/,
    bK = /^\/\//,
    bL = /\?/,
    bM = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
    bN = /^(?:select|textarea)/i,
    bO = /\s+/,
    bP = /([?&])_=[^&]*/,
    bQ = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,
    bR = f.fn.load,
    bS = {},
    bT = {},
    bU, bV, bW = ["*/"] + ["*"];
try {
    bU = e.href;
} catch (bX) {
    bU = c.createElement("a");
    bU.href = "";
    bU = bU.href;
}
bV = bQ.exec(bU.toLowerCase()) || [];
f.fn.extend({
    load: function(a, c, d) {
        if (typeof a !== "string" && bR) return bR.apply(this, arguments);
        if (!this.length) return this;
        var e = a.indexOf(" ");
        if (e >= 0) {
            var g = a.slice(e, a.length);
            a = a.slice(0, e);
        }
        var h = "GET";
        c && (f.isFunction(c) ? (d = c, c = undefined) : typeof c === "object" && (c = f.param(c, f.ajaxSettings.traditional), h = "POST"));
        var i = this;
        f.ajax({
            url: a,
            type: h,
            dataType: "html",
            data: c,
            complete: function(a, b, c) {
                c = a.responseText;
                a.isResolved() && (a.done(function(a) {
                    c = a;
                }), i.html(g ? f("<div>").append(c.replace(bM, "")).find(g) : c));
                d && i.each(d, [c, b, a]);
            }
        });
        return this;
    },
    serialize: function() {
        return f.param(this.serializeArray());
    },
    serializeArray: function() {
        return this.map(function() {
            return this.elements ? f.makeArray(this.elements) : this;
        }).filter(function() {
            return this.name && !this.disabled && (this.checked || bN.test(this.nodeName) || bH.test(this.type));
        }).map(function(a, b) {
            var c = f(this).val();
            return c == null ? null : f.isArray(c) ? f.map(c, function(a, c) {
                return {
                    name: b.name,
                    value: a.replace(bE, "\r\n")
                };
            }) : {
                name: b.name,
                value: c.replace(bE, "\r\n")
            };
        }).get();
    }
});
};
h.promise(v), v.success = v.done, v.error = v.fail, v.complete = i.add, v.statusCode = function(a) {
    if (a) {
        var b;
        if (s < 2)
            for (b in a) j[b] = [j[b], a[b]];
        else b = a[v.status], v.then(b, b)
    }
    return this;
};
d.url = ((a || d.url) + "").replace(bF, "").replace(bK, bV[1] + "//"), d.dataTypes = f.trim(d.dataType || "*").toLowerCase().split(bO), d.crossDomain == null && (r = bQ.exec(d.url.toLowerCase()), d.crossDomain = !(!r || r[1] === bV[1] && r[2] === bV[2] && (r[3] || (r[1] === "http:" ? 80 : 443)) == (bV[3] || (bV[1] === "http:" ? 80 : 443)))), d.data && d.processData && typeof d.data !== "string" && (d.data = f.param(d.data, d.traditional)), bZ(bS, d, c, v);
if (s === 2) return !1;
t = d.global, d.type = d.type.toUpperCase(), d.hasContent = !bJ.test(d.type), t && f.active++ === 0 && f.event.trigger("ajaxStart");
if (!d.hasContent) {
    d.data && (d.url += (bL.test(d.url) ? "&" : "?") + d.data, delete d.data), k = d.url;
    if (d.cache === !1) {
        var x = f.now(),
            y = d.url.replace(bP, "$1_=" + x);
        d.url = y + (y === d.url ? (bL.test(d.url) ? "&" : "?") + "_=" + x : "")
    }
}(d.data && d.hasContent && d.contentType !== !1 || c.contentType) && v.setRequestHeader("Content-Type", d.contentType), d.ifModified && (k = k || d.url, f.lastModified[k] && v.setRequestHeader("If-Modified-Since", f.lastModified[k]), f.etag[k] && v.setRequestHeader("If-None-Match", f.etag[k])), v.setRequestHeader("Accept", d.dataTypes[0] && d.accepts[d.dataTypes[0]] ? d.accepts[d.dataTypes[0]] + (d.dataTypes[0] !== "*" ? ", " + bW + "; q=0.01" : "") : d.accepts["*"]);
for (u in d.headers) v.setRequestHeader(u, d.headers[u]);
if (d.beforeSend && (d.beforeSend.call(e, v, d) === !1 || s === 2)) {
    v.abort();
    return !1
}
for (u in {
        success: 1,
        error: 1,
        complete: 1
    }) v[u](d[u]);
q = bY(bT, d, c, v);
if (!q) w(-1, "No Transport");
else {
    v.readyState = 1, t && g.trigger("ajaxSend", [v, d]), d.async && d.timeout > 0 && (r = setTimeout(function() {
        v.abort("timeout")
    }, d.timeout));
    try {
        s = 1, q.send(l, w)
    } catch (z) {
        status < 2 ? w(-1, z) : f.error(z)
    }
}
return v
},
param: function(a, c) {
var d = [],
    e = function(a, b) {
        b = f.isFunction(b) ? b() : b == null ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
    };
c === b && (c = f.ajaxSettings.traditional);
if (f.isArray(a) || a.jquery && !f.isPlainObject(a)) f.each(a, function() {
    e(this.name, this.value)
});
else
    for (var g in a) b$(g, a[g], c, e);
return d.join("&").replace(bC, "+")
}
}), f.extend({
active: 0,
lastModified: {},
etag: {}
});
var cc = f.now(),
cd = /(\=)\?(&|$)|\?\?/i;
f.ajaxSetup({
jsonp: "callback",
jsonpCallback: function() {
return f.expando + "_" + cc++
}
}), f.ajaxPrefilter("json jsonp", function(b, c, d) {
var e = typeof b.data === "string" && /^application\/x\-www\-form\-urlencoded/.test(b.contentType);
if (b.dataTypes[0] === "jsonp" || b.jsonp !== !1 && (cd.test(b.url) || e && cd.test(b.data))) {
var g, h = b.jsonpCallback = f.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback,
    i = a[h],
    j = b.url,
    k = b.data,
    l = "$1" + h + "$2";
b.jsonp !== !1 && (j = j.replace(cd, l), b.url === j && (e && (k = k.replace(cd, l)), b.data === k && (j += (/\?/.test(j) ? "&" : "?") + b.jsonp + "=" + h))), b.url = j, b.data = k, a[h] = function(a) {
    g = [a]
}, d.always(function() {
    a[h] = i, g && f.isFunction(i) && a[h](g[0])
}), b.converters["script json"] = function() {
    g || f.error(h + " was not called");
    return g[0]
}, b.dataTypes[0] = "json";
return "script"
}
}), f.ajaxSetup({
accepts: {
script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
},
contents: {
script: /javascript|ecmascript/
},
converters: {
"text script": function(a) {
    f.globalEval(a);
    return a
}
}
}), f.ajaxPrefilter("script", function(a) {
if (a.cache === b) a.cache = !1;
if (a.crossDomain) {
a.type = "GET", a.global = !1
}
}), f.ajaxTransport("script", function(a) {
if (a.crossDomain) {
var d, e = c.head || c.getElementsByTagName("head")[0] || c.documentElement;
return {
    send: function(f, g) {
        d = c.createElement("script"), d.async = "async", a.scriptCharset && (d.charset = a.scriptCharset), d.src = a.url, d.onload = d.onreadystatechange = function(a, c) {
            if (c || !d.readyState || /loaded|complete/.test(d.readyState)) d.onload = d.onreadystatechange = null, e && d.parentNode && e.removeChild(d), d = b, c || g(200, "success")
        }, e.insertBefore(d, e.firstChild)
    },
    abort: function() {
        if (d) d.onload(0, 1)
    }
}
}
});
var ce = a.ActiveXObject ? function() {
for (var a in cg) cg[a](0, 1)
} : !1,
cf = 0,
cg;
f.ajaxSettings.xhr = a.ActiveXObject ? function() {
return !this.isLocal && ch() || ci()
} : ch,
function(a) {
f.extend(f.support, {
    ajax: !!a,
    cors: !!a && ("withCredentials" in a)
})
}(f.ajaxSettings.xhr()), f.support.ajax && f.ajaxTransport(function(c) {
if (!c.crossDomain || f.support.cors) {
    var d;
    return {
        send: function(e, g) {
            var h = c.xhr(),
                i, j;
            c.username ? h.open(c.type, c.url, c.async, c.username, c.password) : h.open(c.type, c.url, c.async);
            if (c.xhrFields)
                for (j in c.xhrFields) h[j] = c.xhrFields[j];
            c.mimeType && h.overrideMimeType && h.overrideMimeType(c.mimeType), !c.crossDomain && !e["X-Requested-With"] && (e["X-Requested-With"] = "XMLHttpRequest");
            try {
                for (j in e) h.setRequestHeader(j, e[j])
            } catch (k) {}
            h.send(c.hasContent && c.data || null), d = function(a, e) {
                var j, k, l, m, n;
                try {
                    if (d && (e || h.readyState === 4)) {
                        d = b, i && (h.onreadystatechange = f.noop, ce && delete cg[i]);
                        if (e) h.readyState !== 4 && h.abort();
                        else {
                            j = h.status, l = h.getAllResponseHeaders(), m = {}, n = h.responseXML, n && n.documentElement && (m.xml = n);
                            try {
                                m.text = h.responseText
                            } catch (a) {}
                            try {
                                k = h.statusText
                            } catch (o) {
                                k = ""
                            }!j && c.isLocal && !c.crossDomain ? j = m.text ? 200 : 404 : j === 1223 && (j = 204)
                        }
                    }
                } catch (p) {
                    e || g(-1, p)
                }
                m && g(j, k, m, l)
            }, !c.async || h.readyState === 4 ? d() : (i = ++cf, ce && (cg || (cg = {}, f(a).unload(ce)), cg[i] = d), h.onreadystatechange = d)
        },
        abort: function() {
            d && d(0, 1)
        }
    }
}
});
var cj = {},
ck, cl, cm = /^(?:toggle|show|hide)$/,
cn = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
co, cp = [
["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
["opacity"]
],
cq;
f.fn.extend({
show: function(a, b, c) {
var d, e;
if (a || a === 0) return this.animate(cu("show", 3), a, b, c);
for (var g = 0, h = this.length; g < h; g++) d = this[g], d.style && (e = d.style.display, !f._data(d, "olddisplay") && e === "none" && (e = d.style.display = ""), e === "" && f.css(d, "display") === "none" && f._data(d, "olddisplay", cv(d.nodeName)));
for (g = 0; g < h; g++) {
    d = this[g];
    if (d.style) {
        e = d.style.display;
        if (e === "" || e === "none") d.style.display = f._data(d, "olddisplay") || ""
    }
}
return this
},
hide: function(a, b, c) {
if (a || a === 0) return this.animate(cu("hide", 3), a, b, c);
for (var d = 0, e = this.length; d < e; d++) {
    var g = f.css(this[d], "display");
    g !== "none" && !f._data(this[d], "olddisplay") && f._data(this[d], "olddisplay", g)
}
for (d = 0; d < e; d++) this[d].style.display = "none";
return this
},
_toggle: f.fn.toggle,
toggle: function(a, b, c) {
var d = typeof a === "boolean";
f.isFunction(a) && f.isFunction(b) ? this._toggle.apply(this, arguments) : a == null || d ? this.each(function() {
    var b = d ? a : f(this).is(":hidden");
    f(this)[b ? "show" : "hide"]()
}) : this.animate(cu("toggle", 3), a, b, c);
return this
},
fadeTo: function(a, b, c, d) {
return this.filter(":hidden").css("opacity", 0).show().end().animate({
    opacity: b
}, a, c, d)
},
animate: function(a, b, c, d) {
function g() {
    e.queue === !1 && f._mark(this);
    var b = f.extend({}, e),
        c = this.nodeType === 1,
        d = c && f(this).is(":hidden"),
        g, h, i, j, k, l, m, n, o, p, q;
    b.animatedProperties = {};
    for (i in a) {
        g = f.camelCase(i), i !== g && (a[g] = a[i], delete a[i]), h = a[g], f.isArray(h) ? (b.animatedProperties[g] = h[1], h = a[g] = h[0]) : b.animatedProperties[g] = b.specialEasing && b.specialEasing[g] || b.easing || "swing";
        if (h === "hide" && d || h === "show" && !d) return b.complete.call(this);
        c && (g === "height" || g === "width") && (b.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY], f.css(this, "display") === "inline" && f.css(this, "float") === "none" && (!f.support.inlineBlockNeedsLayout || cv(this.nodeName) === "inline" ? this.style.display = "inline-block" : this.style.zoom = 1))
    }
    b.overflow != null && (this.style.overflow = "hidden");
    for (i in a) {
        j = new f.fx(this, b, i), h = a[i];
        if (cm.test(h)) j[h === "toggle" ? d ? "show" : "hide" : h]();
        else {
            k = cn.exec(h), l = j.cur();
            if (k) {
                m = parseFloat(k[2]), n = k[3] || (f.cssNumber[i] ? "" : "px");
                if (n !== "px") {
                    f.style(this, i, (m || 1) + n);
                    l = (m || 1) / j.cur() * l;
                    f.style(this, i, l + n)
                }
                k[1] && (m = (k[1] === "-=" ? -1 : 1) * m + l), j.custom(l, m, n)
            } else j.custom(l, h, "")
        }
    }
    return !0
}
var e = f.speed(b, c, d);
if (f.isEmptyObject(a)) return this.each(e.complete, [!1]);
a = f.extend({}, a);
return e.queue === !1 ? this.each(g) : this.queue(e.queue, g)
},
stop: function(a, c, d) {
typeof a !== "string" && (d = c, c = a, a = b), c && a !== !1 && this.queue(a || "fx", []);
return this.each(function() {
    function h(a, b, c) {
        var e = b[c];
        f.removeData(a, c, !0), e.stop(d)
    }
    var b, c = !1,
        e = f.timers,
        g = f._data(this);
    d || f._unmark(!0, this);
    if (a == null)
        for (b in g) g[b] && g[b].stop && b.indexOf(".run") === b.length - 4 && h(this, g, b);
    else g[b = a + ".run"] && g[b].stop && h(this, g, b);
    for (b = e.length; b--;)
        if (e[b].elem === this && (a == null || e[b].queue === a)) {
            d ? e[b](!0) : e[b].saveState();
            c = !0;
            e.splice(b, 1)
        }
    (!d || !c) && f.dequeue(this, a)
})
}
}), f.each({
slideDown: cu("show", 1),
slideUp: cu("hide", 1),
slideToggle: cu("toggle", 1),
fadeIn: {
opacity: "show"
},
fadeOut: {
opacity: "hide"
},
fadeToggle: {
opacity: "toggle"
}
}, function(a, b) {
f.fn[a] = function(a, c, d) {
return this.animate(b, a, c, d)
}
}), f.extend({
speed: function(a, b, c) {
var d = a && typeof a === "object" ? f.extend({}, a) : {
    complete: c || !c && b || f.isFunction(a) && a,
    duration: a,
    easing: c && b || b && !f.isFunction(b) && b
};
d.duration = f.fx.off ? 0 : typeof d.duration === "number" ? d.duration : d.duration in f.fx.speeds ? f.fx.speeds[d.duration] : f.fx.speeds._default;
if (d.queue == null || d.queue === !0) d.queue = "fx";
d.old = d.complete, d.complete = function(a) {
    f.isFunction(d.old) && d.old.call(this), d.queue ? f.dequeue(this, d.queue) : a !== !1 && f._unmark(this)
};
return d
},
easing: {
linear: function(a, b, c, d) {
    return c + d * a
},
swing: function(a, b, c, d) {
    return (-Math.cos(a * Math.PI) / 2 + 0.5) * d + c
}
},
timers: [],
fx: function(a, b, c) {
this.options = b, this.elem = a, this.prop = c, b.orig = b.orig || {}
}
}), f.fx.prototype = {
update: function() {
this.options.step && this.options.step.call(this.elem, this.now, this), (f.fx.step[this.prop] || f.fx.step._default)(this)
},
cur: function() {
if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) return this.elem[this.prop];
var a, b = f.css(this.elem, this.prop);
return isNaN(a = parseFloat(b)) ? !b || b === "auto" ? 0 : b : a
},
custom: function(a, c, d) {
function h(a) {
    return e.step(a)
}
var e = this,
    g = f.fx;
this.startTime = cq || cr(), this.end = c, this.now = this.start = a, this.pos = this.state = 0, this.unit = d || this.unit || (f.cssNumber[this.prop] ? "" : "px"), h.queue = this.options.queue, h.elem = this.elem, h.saveState = function() {
    if (e.options.hide && f._data(e.elem, "fxshow" + e.prop) === b) f._data(e.elem, "fxshow" + e.prop, e.start)
}, h() && f.timers.push(h) && !co && (co = setInterval(g.tick, g.interval))
},
show: function() {
var a = f._data(this.elem, "fxshow" + this.prop);
this.options.orig[this.prop] = a || f.style(this.elem, this.prop), this.options.show = !0, a !== b ? this.custom(this.cur(), a) : this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur()), f(this.elem).show()
},
hide: function() {
this.options.orig[this.prop] = f._data(this.elem, "fxshow" + this.prop) || f.style(this.elem, this.prop), this.options.hide = !0, this.custom(this.cur(), 0)
},
step: function(a) {
var b, c, d = cq || cr(),
    e = !0,
    g = this.elem,
    h = this.options;
if (a || d >= h.duration + this.startTime) {
    this.now = this.end, this.pos = this.state = 1, this.update(), h.animatedProperties[this.prop] = !0;
    for (b in h.animatedProperties) h.animatedProperties[b] !== !0 && (e = !1);
    if (e) {
        h.overflow != null && !f.support.shrinkWrapBlocks && f.each(["", "X", "Y"], function(a, b) {
            g.style["overflow" + b] = h.overflow[a]
        }), h.hide && f(g).hide();
        if (h.hide || h.show)
            for (b in h.animatedProperties) f.style(g, b, h.orig[b]), f.removeData(g, "fxshow" + b, !0), f.removeData(g, "toggle" + b, !0);
        c = h.complete, c && (h.complete = !1, c.call(g))
    }
    return !1
}
h.duration == Infinity ? this.now = d : (c = d - this.startTime, this.state = c / h.duration, this.pos = f.easing[h.animatedProperties[this.prop]](this.state, c, 0, 1, h.duration), this.now = this.start + (this.end - this.start) * this.pos), this.update();
return !0
}
}, f.extend(f.fx, {
tick: function() {
var a, b = f.timers,
    c = 0;
for (; c < b.length; c++) a = b[c], !a() && b[c] === a && b.splice(c--, 1);
b.length || f.fx.stop()
},
interval: 13,
stop: function() {
clearInterval(co), co = null
},
speeds: {
slow: 600,
fast: 200,
_default: 400
},
step: {
opacity: function(a) {
    f.style(a.elem, "opacity", a.now)
},
_default: function(a) {
    a.elem.style && a.elem.style[a.prop] != null ? a.elem.style[a.prop] = a.now + a.unit : a.elem[a.prop] = a.now
}
}
}), f.expr && f.expr.filters && (f.expr.filters.animated = function(a) {
return f.grep(f.timers, function(b) {
return a === b.elem
}).length
});
var cw = /^t(?:able|d|h)$/i,
cx = /^(?:body|html)$/i;
"getBoundingClientRect" in c.documentElement ? f.fn.offset = function(a) {
var b = this[0],
c;
if (a) return this.each(function(b) {
f.offset.setOffset(this, a, b)
});
if (!b || !b.ownerDocument) return null;
if (b === b.ownerDocument.body) return f.offset.bodyOffset(b);
try {
c = b.getBoundingClientRect()
} catch (d) {}
var e = b.ownerDocument,
g = e.documentElement;
if (!c || !f.contains(g, b)) return c ? {
top: c.top,
left: c.left
} : {
top: 0,
left: 0
};
var h = e.body,
i = cy(e),
j = g.clientTop || h.clientTop || 0,
k = g.clientLeft || h.clientLeft || 0,
l = i.pageYOffset || f.support.boxModel && g.scrollTop || h.scrollTop,
m = i.pageXOffset || f.support.boxModel && g.scrollLeft || h.scrollLeft,
n = c.top + l - j,
o = c.left + m - k;
return {
top: n,
left: o
}
} : f.fn.offset = function(a) {
var b = this[0];
if (a) return this.each(function(b) {
f.offset.setOffset(this, a, b)
});
if (!b || !b.ownerDocument) return null;
if (b === b.ownerDocument.body) return f.offset.bodyOffset(b);
var c, d = b.offsetParent,
e = b,
g = b.ownerDocument,
h = g.documentElement,
i = g.body,
j = g.defaultView,
k = j ? j.getComputedStyle(b, null) : b.currentStyle,
l = b.offsetTop,
m = b.offsetLeft;
while ((b = b.parentNode) && b !== i && b !== h) {
if (f.support.fixedPosition && k.position === "fixed") break;
c = j ? j.getComputedStyle(b, null) : b.currentStyle, l -= b.scrollTop, m -= b.scrollLeft, b === d && (l += b.offsetTop, m += b.offsetLeft, f.support.doesNotAddBorder && (!f.support.doesAddBorderForTableAndCells || !cw.test(b.nodeName)) && (l += parseFloat(c.borderTopWidth) || 0, m += parseFloat(c.borderLeftWidth) || 0), e = d, d = b.offsetParent), f.support.subtractsBorderForOverflowNotVisible && c.overflow !== "visible" && (l += parseFloat(c.borderTopWidth) || 0, m += parseFloat(c.borderLeftWidth) || 0), k = c
}
if (k.position === "relative" || k.position === "static") l += i.offsetTop, m += i.offsetLeft;
f.support.fixedPosition && k.position === "fixed" && (l += Math.max(h.scrollTop, i.scrollTop), m += Math.max(h.scrollLeft, i.scrollLeft));
return {
top: l,
left: m
}
}, f.offset = {
bodyOffset: function(a) {
var b = a.offsetTop,
    c = a.offsetLeft;
f.support.doesNotIncludeMarginInBodyOffset && (b += parseFloat(f.css(a, "marginTop")) || 0, c += parseFloat(f.css(a, "marginLeft")) || 0);
return {
    top: b,
    left: c
}
},
setOffset: function(a, b, c) {
var d = f.css(a, "position");
d === "static" && (a.style.position = "relative");
var e = f(a),
    g = e.offset(),
    h = f.css(a, "top"),
    i = f.css(a, "left"),
    j = {}, k = {};
(d === "absolute" || d === "fixed") && f.inArray("auto", [h, i]) > -1 ? (k = e.position(), h = k.top, i = k.left) : (h = parseFloat(h) || 0, i = parseFloat(i) || 0), f.isFunction(b) && (b = b.call(a, c, g)), b.top != null && (j.top = b.top - g.top + h), b.left != null && (j.left = b.left - g.left + i), "using" in b ? b.using.call(a, j) : e.css(j)
}
}, f.fn.extend({
position: function() {
if (!this[0]) return null;
var a = this[0],
    b = this.offsetParent(),
    c = this.offset(),
    d = cx.test(b[0].nodeName) ? {
        top: 0,
        left: 0
    } : b.offset();
c.top -= parseFloat(f.css(a, "marginTop")) || 0, c.left -= parseFloat(f.css(a, "marginLeft")) || 0, d.top += parseFloat(f.css(b[0], "borderTopWidth")) || 0, d.left += parseFloat(f.css(b[0], "borderLeftWidth")) || 0;
return {
    top: c.top - d.top,
    left: c.left - d.left
}
},
offsetParent: function() {
return this.map(function() {
    var a = this.offsetParent || c.body;
    while (a && !cx.test(a.nodeName) && f.css(a, "position") === "static") a = a.offsetParent;
    return a
})
}
}), f.each(["Left", "Top"], function(a, c) {
var d = "scroll" + c;
f.fn[d] = function(c) {
var e, g;
if (c === b) {
    e = this[0];
    if (!e) return null;
    g = cy(e);
    return g ? "pageXOffset" in g ? g[a ? "pageYOffset" : "pageXOffset"] : f.support.boxModel && g.document.documentElement[d] || g.document.body[d] : e[d]
}
return this.each(function() {
    g = cy(this), g ? g.scrollTo(a ? f(g).scrollLeft() : c, a ? c : f(g).scrollTop()) : this[d] = c
})
}
}), f.each(["Height", "Width"], function(a, c) {
var d = c.toLowerCase();
f.fn["inner" + c] = function() {
var a = this[0];
return a && a.style ? parseFloat(f.css(a, d, "padding")) : null
}, f.fn["outer" + c] = function(a) {
var b = this[0];
return b && b.style ? parseFloat(f.css(b, d, a ? "margin" : "border")) : null
}, f.fn[d] = function(a) {
var e = this[0];
if (!e) return a == null ? null : this;
if (f.isFunction(a)) return this.each(function(b) {
    var c = f(this);
    c[d](a.call(this, b, c[d]()))
});
if (f.isWindow(e)) {
    var g = e.document.documentElement["client" + c],
        h = e.document.body;
    return e.document.compatMode === "CSS1Compat" && g || h && h["client" + c] || g
}
if (e.nodeType === 9) {
    var i = e.documentElement;
    if (i["client" + c] >= i["scroll" + c]) return i["client" + c];
    return Math.max(e.body["scroll" + c], i["scroll" + c], e.body["offset" + c], i["offset" + c])
}
if (a === b) {
    var j = f.css(e, d),
        k = parseFloat(j);
    return f.isNaN(k) ? j : k
}
return this.css(d, typeof a === "string" ? a : a + "px")
}
})
(window);


// Menggunakan navigator.userAgent untuk mendeteksi browser
var browser = navigator.userAgent;

// Menggunakan document.compatMode untuk mendukung model box
var boxModel = document.compatMode;

// Menggunakan $.trim() untuk mengganti jQuery.trim()
var trimmedString = $.trim(string);

// Menggunakan $.now() untuk mengganti jQuery.now()
var currentTime = $.now();

// Menggunakan $.isFunction() untuk mengganti jQuery.isFunction()
var isFunc = $.isFunction(func);

// Menggunakan $.isArray() untuk mengganti jQuery.isArray()
var arr = $.isArray(array);

// Menggunakan $.param() untuk mengganti jQuery.param()
var params = $.param(object);

// Menggunakan $.error() untuk mengganti jQuery.error()
$.error("This is an error message");

// Menggunakan $.globalEval() untuk mengganti jQuery.globalEval()
$.globalEval("console.log('Global evaluation')");

// Mengganti success, error, dan complete dengan done, fail, dan always
$.ajax({
    url: "example.php",
    success: function(response) {
        console.log("Success:", response);
    },
    error: function(xhr, status, error) {
        console.error("Error:", error);
    },
    complete: function(xhr, status) {
        console.log("Request completed");
    }
}).done(function(response) {
    console.log("Success:", response);
}).fail(function(xhr, status, error) {
    console.error("Error:", error);
}).always(function(xhr, status) {
    console.log("Request completed");
});
// Mengganti event unload dengan event beforeunload
f(window).on("beforeunload", ce);

// Mengganti $.fn.bind() dengan $.fn.on()
f(document).on("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend", function(a) {
    f.fn[a.type].call(this, function() {});
});

// Menggunakan $.ajaxSetup() untuk mengatur default ajax options
f.ajaxSetup({
    cache: false,
    global: false
});

// Menggunakan $.ajaxPrefilter() untuk memodifikasi default ajax options sebelum permintaan dikirim
f.ajaxPrefilter(function(a) {
    if (a.crossDomain) {
        a.type = "GET";
        a.global = false;
    }
});

// Menggunakan $.ajaxTransport() untuk mendukung permintaan ajax lintas domain
f.ajaxTransport(function(a) {
    if (a.crossDomain) {
        var xhr;
        return {
            send: function(headers, callback) {
                xhr = new XMLHttpRequest();
                xhr.open("GET", a.url, true);
                xhr.onload = function() {
                    if (xhr.status === 200) {
                        callback(null, xhr.responseText);
                    } else {
                        callback(xhr.statusText);
                    }
                };
                xhr.onerror = function() {
                    callback(xhr.statusText);
                };
                xhr.send();
            },
            abort: function() {
                if (xhr) {
                    xhr.abort();
                }
            }
        };
    }
});

// Menggunakan $.fn.animate() untuk efek animasi
f.fn.extend({
    show: function(duration, easing, callback) {
        if (duration || duration === 0) {
            return this.animate({ opacity: "show" }, duration, easing, callback);
        } else {
            return this.animate({ opacity: "show" }, "fast", easing, callback);
        }
    }
});
hide: function(duration, easing, callback) {
    if (duration || duration === 0) {
        return this.animate({ opacity: "hide" }, duration, easing, callback);
    }
    var displayValue, element, index = 0,
        length = this.length;
    for (; index < length; index++) {
        element = this[index];
        if (element.style) {
            displayValue = f.css(element, "display");
            if (displayValue !== "none" && !f._data(element, "olddisplay")) {
                f._data(element, "olddisplay", displayValue);
            }
        }
    }
    for (index = 0; index < length; index++) {
        element = this[index];
        if (element.style) {
            element.style.display = "none";
        }
    }
    return this;
},
_toggle: f.fn.toggle,
toggle: function(duration, easing, callback) {
    var isBoolean = typeof duration === "boolean";
    if (f.isFunction(duration) && f.isFunction(easing)) {
        return this._toggle.apply(this, arguments);
    } else if (duration == null || isBoolean) {
        return this.each(function() {
            var isHidden = isBoolean ? duration : f(this).is(":hidden");
            f(this)[isHidden ? "show" : "hide"]();
        });
    } else {
        return this.animate({ opacity: "toggle" }, duration, easing, callback);
    }
},
fadeTo: function(duration, opacity, easing, callback) {
    return this.filter(":hidden").css("opacity", 0).show().end().animate({
        opacity: opacity
    }, duration, easing, callback);
},
animate: function(properties, duration, easing, callback) {
    function step() {
        if (options.queue === false) {
            f._mark(this);
        }
        var animatedProperties = {},
            nodeType = this.nodeType === 1,
            isHidden = nodeType && f(this).is(":hidden"),
            name, val, parts, start, end, unit, method;
        options.animatedProperties = {};
        for (name in properties) {
            val = f.camelCase(name);
            if (name !== val) {
                properties[val] = properties[name];
                delete properties[name];
            }
            if ((parts = f.cssHooks[val]) && "expand" in parts) {
                parts = parts.expand(properties[val]);
                delete properties[val];
                for (name in parts) {
                    if (!(name in properties)) {
                        properties[name] = parts[name];
                    }
                }
            }
        }
        for (name in properties) {
            val = properties[name];
            f.isArray(val) ? (animatedProperties[name] = val[1], val = properties[name] = val[0]) : animatedProperties[name] = options.specialEasing && options.specialEasing[name] || options.easing || "swing";
            if (val === "hide" && isHidden || val === "show" && !isHidden) {
                return options.complete.call(this);
            }
            if (nodeType && (name === "height" || name === "width")) {
                options.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];
                if (f.css(this, "display") === "inline" && f.css(this, "float") === "none") {
                    if (!f.support.inlineBlockNeedsLayout || cu(this.nodeName) === "inline") {
                        this.style.display = "inline-block";
                    } else {
                        this.style.zoom = 1;
                    }
                }
            }
        }
        if (options.overflow != null) {
            this.style.overflow = "hidden";
        }
        for (name in properties) {
            method = new f.fx(this, options, name);
            val = properties[name];
            if (cm.test(val)) {
                parts = f._data(this, "toggle" + name) || (val === "toggle" ? (isHidden ? "show" : "hide") : 0);
                if (parts) {
                    f._data(this, "toggle" + name, parts === "show" ? "hide" : "show");
                    method[parts]();
                } else {
                    method[val]();
                }
            } else {
                parts = cn.exec(val);
                start = method.cur();
                if (parts) {
                    end = parseFloat(parts[2]);
                    unit = parts[3] || (f.cssNumber[name] ? "" : "px");
                    if (unit !== "px") {
                        f.style(this, name, (end || 1) + unit);
                        start = ((end || 1) / method.cur()) * start;
                        f.style(this, name, start + unit);
                    }
                    if (parts[1]) {
                        end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                    }
                    method.custom(start, end, unit);
                } else {
                    method.custom(start, val, "");
                }
            }
        }
        return true;
    }
    var options = f.speed(duration, easing, callback);
    if (f.isEmptyObject(properties)) {
        return this.each(options.complete, [false]);
    }
    properties = f.extend({}, properties);
    return options.queue === false ? this.each(step) : this.queue(options.queue, step);
},
stop: function(queue, clearQueue, gotoEnd) {
    if (typeof queue !== "string") {
        gotoEnd = clearQueue;
        clearQueue = queue;
        queue = undefined;
    }
    if (clearQueue && queue !== false) {
        this.queue(queue || "fx", []);
    }
    return this.each(function() {
        function clearTimers(elem, type) {
            var timer = type && elem[type] || [];
            f.removeData(elem, type, true);
            for (var i = timer.length; i--;) {
                timer[i].stop(gotoEnd);
            }
        }
        var index, timers = f.timers,
            data = f._data(this),
            type = data && data.queue,
            i = timers.length;
        if (queue) {
            if (type) {
                clearTimers(this, type);
            }
        } else {
            for (type in data) {
                if (data[type] && type.indexOf(".run") === type.length - 4) {
                    clearTimers(this, type);
                }
            }
        }
        while (i--) {
            if (timers[i].elem === this && (queue == null || timers[i].queue === queue)) {
                if (gotoEnd) {
                    timers[i](true);
                } else {
                    timers[i].saveState();
                }
                index = true;
                timers.splice(i, 1);
            }
        }
        if (!(gotoEnd && index)) {
            f.dequeue(this, queue);
        }
    });
}
f.each({
    slideDown: ct("show", 1),
    slideUp: ct("hide", 1),
    slideToggle: ct("toggle", 1),
    fadeIn: {
        opacity: "show"
    },
    fadeOut: {
        opacity: "hide"
    },
    fadeToggle: {
        opacity: "toggle"
    }
}, function(name, props) {
    f.fn[name] = function(duration, easing, callback) {
        return this.animate(props, duration, easing, callback);
    };
});

f.extend({
    speed: function(duration, easing, callback) {
        var options = duration && typeof duration === "object" ? f.extend({}, duration) : {
            complete: callback || !callback && easing || f.isFunction(duration) && duration,
            duration: duration,
            easing: callback && easing || easing && !f.isFunction(easing) && easing
        };
        options.duration = f.fx.off ? 0 : typeof options.duration === "number" ? options.duration : options.duration in f.fx.speeds ? f.fx.speeds[options.duration] : f.fx.speeds._default;
        if (options.queue == null || options.queue === true) {
            options.queue = "fx";
        }
        options.old = options.complete;
        options.complete = function() {
            if (f.isFunction(options.old)) {
                options.old.call(this);
            }
            if (options.queue) {
                f.dequeue(this, options.queue);
            } else {
                f._unmark(this);
            }
        };
        return options;
    },
    easing: {
        linear: function(progress) {
            return progress;
        },
        swing: function(progress) {
            return -Math.cos(progress * Math.PI) / 2 + 0.5;
        }
    },
    timers: [],
    fx: function(elem, options, prop) {
        this.options = options;
        this.elem = elem;
        this.prop = prop;
        options.orig = options.orig || {};
    }
});

f.fx.prototype = {
    update: function() {
        this.options.step && this.options.step.call(this.elem, this.now, this);
        (f.fx.step[this.prop] || f.fx.step._default)(this);
    },
    cur: function() {
        if (this.elem[this.prop] != null && (!this.elem.style || this.elem.style[this.prop] == null)) {
            return this.elem[this.prop];
        }
        var parsed, value = f.css(this.elem, this.prop);
        return isNaN(parsed = parseFloat(value)) ? !value || value === "auto" ? 0 : value : parsed;
    },
    custom: function(from, to, unit) {
        var self = this,
            fx = f.fx,
            startTime = cq || cr(),
            method = function(progress) {
                return self.step(progress);
            },
            start = this.cur(),
            end = to,
            pos, state, unitName = unit || (f.cssNumber[this.prop] ? "" : "px"),
            queue = this.options.queue,
            elem = this.elem,
            animatedProperties = fx.prototype.options.animatedProperties;
        
        method.queue = this.options.queue;

        method.elem = elem;

        method.saveState = function() {
            if (f._data(self.elem, "fxshow" + self.prop) === undefined) {
                if (self.options.hide) {
                    f._data(self.elem, "fxshow" + self.prop, start);
                } else if (self.options.show) {
                    f._data(self.elem, "fxshow" + self.prop, end);
                }
            }
        };

        method() && f.timers.push(method) && !co && (co = setInterval(fx.tick, fx.interval));
    },
    show: function() {
        var showValue = f._data(this.elem, "fxshow" + this.prop);
        this.options.orig[this.prop] = showValue || f.style(this.elem, this.prop);
        this.options.show = true;
        if (showValue !== undefined) {
            this.custom(this.cur(), showValue);
        } else {
            this.custom(this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur());
        }
        f(this.elem).show();
    },
    hide: function() {
        this.options.orig[this.prop] = f._data(this.elem, "fxshow" + this.prop) || f.style(this.elem, this.prop);
        this.options.hide = true;
        this.custom(this.cur(), 0);
    },
    step: function(now) {
        var tweening, action, startTime = cq || cr(),
            progress = true,
            elem = this.elem,
            options = this.options;

        if (now || startTime >= options.duration + this.startTime) {
            this.now = this.end;
            this.pos = this.state = 1;
            this.update();
            options.animatedProperties[this.prop] = true;

            for (tweening in options.animatedProperties) {
                if (options.animatedProperties[tweening] !== true) {
                    progress = false;
                }
            }

            if (progress) {
                if (options.overflow != null && !f.support.shrinkWrapBlocks) {
                    f.each(["", "X", "Y"], function(index, value) {
                        elem.style["overflow" + value] = options.overflow[index];
                    });
                }

                if (options.hide) {
                    f(elem).hide();
                }

                if (options.hide || options.show) {
                    for (tweening in options.animatedProperties) {
                        f.style(elem, tweening, options.orig[tweening]);
                        f.removeData(elem, "fxshow" + tweening, true);
                        f.removeData(elem, "toggle" + tweening, true);
                    }
                }

                action = options.complete;
                if (action) {
                    options.complete = false;
                    action.call(elem);
                }
            }
            return false;
        } else {
            options.duration == Infinity ? this.now = startTime : (tweening = startTime - this.startTime, this.state = tweening / options.duration, this.pos = f.easing[options.animatedProperties[this.prop]](this.state, tweening, 0, 1, options.duration), this.now = this.start + (this.end - this.start) * this.pos);

            this.update();
        }
        return true;
    }
};
(function(global, factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) :
            function(w) {
                if (!w.document) {
                    throw new Error("jQuery requires a window with a document");
                }
                return factory(w);
            };
    } else {
        factory(global);
    }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
    var jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    };

    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,
        init: function(selector, context) {
            // Your initialization logic here
        }
        // More methods...
    };

    // Define jQuery extend and other methods

    jQuery.fn.init.prototype = jQuery.fn;

    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }

    return jQuery;
}));
